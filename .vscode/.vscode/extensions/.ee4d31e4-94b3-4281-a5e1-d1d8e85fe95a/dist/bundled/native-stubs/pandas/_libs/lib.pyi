# Python: 3.9.2 (tags/v3.9.2:1a79785, Feb 19 2021, 13:44:55) [MSC v.1928 64 bit (AMD64)]
# Library: pandas, version: 1.2.4
# Module: pandas._libs.lib, version: unspecified
import typing
import builtins as _mod_builtins
import decimal as _mod_decimal

class AnyTimedeltaValidator(TimedeltaValidator):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

class BoolValidator(Validator):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

class BytesValidator(Validator):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

class ComplexValidator(Validator):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

class DateValidator(Validator):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

class Datetime64Validator(DatetimeValidator):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

class DatetimeValidator(TemporalValidator):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

Decimal = _mod_decimal.Decimal
class DecimalValidator(Validator):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

class FloatValidator(Validator):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

class IntegerFloatValidator(Validator):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

class IntegerNaValidator(Validator):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

class IntegerValidator(Validator):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

class IntervalValidator(Validator):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

class PeriodValidator(TemporalValidator):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

class Seen(_mod_builtins.object):
    '\n    Class for keeping track of the types of elements\n    encountered when trying to perform type conversions.\n    '
    def __init__(self, *args, **kwargs) -> None:
        '\n    Class for keeping track of the types of elements\n    encountered when trying to perform type conversions.\n    '
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    @property
    def is_bool(self) -> typing.Any:
        ...
    
    @property
    def is_float_or_complex(self) -> typing.Any:
        ...
    
    @property
    def numeric_(self) -> typing.Any:
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

class StringValidator(Validator):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

class TemporalValidator(Validator):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

class TimeValidator(Validator):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

class TimedeltaValidator(TemporalValidator):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

class Validator(_mod_builtins.object):
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @classmethod
    def __init_subclass__(cls) -> None:
        'This method is called when a class is subclassed.\n\nThe default implementation does nothing. It may be\noverridden to extend subclasses.\n'
        ...
    
    __pyx_vtable__: PyCapsule
    def __reduce__(self) -> typing.Union[str, typing.Tuple[typing.Any, ...]]:
        ...
    
    def __setstate__(self, state: typing.Any) -> None:
        ...
    
    @classmethod
    def __subclasshook__(cls, subclass: typing.Any) -> bool:
        'Abstract classes can override this to customize issubclass().\n\nThis is invoked early on by abc.ABCMeta.__subclasscheck__().\nIt should return True, False or NotImplemented.  If it returns\nNotImplemented, the normal algorithm is used.  Otherwise, it\noverrides the normal algorithm (and the outcome is cached).\n'
        ...
    
    def __getattr__(self, name) -> typing.Any:
        ...
    

_TYPE_MAP: dict
__doc__: typing.Any
__file__: str
__name__: str
__package__: str
__pyx_capi__: dict
def __pyx_unpickle_Enum() -> typing.Any:
    ...

__test__: dict
def array_equivalent_object() -> typing.Any:
    '\n    Perform an element by element comparison on 1-d object arrays\n    taking into account nan positions.\n    '
    ...

def array_to_datetime() -> typing.Any:
    "\n    Converts a 1D array of date-like values to a numpy array of either:\n        1) datetime64[ns] data\n        2) datetime.datetime objects, if OutOfBoundsDatetime or TypeError\n           is encountered\n\n    Also returns a pytz.FixedOffset if an array of strings with the same\n    timezone offset is passed and utc=True is not passed. Otherwise, None\n    is returned\n\n    Handles datetime.date, datetime.datetime, np.datetime64 objects, numeric,\n    strings\n\n    Parameters\n    ----------\n    values : ndarray of object\n         date-like objects to convert\n    errors : str, default 'raise'\n         error behavior when parsing\n    dayfirst : bool, default False\n         dayfirst parsing behavior when encountering datetime strings\n    yearfirst : bool, default False\n         yearfirst parsing behavior when encountering datetime strings\n    utc : bool, default False\n         indicator whether the dates should be UTC\n    require_iso8601 : bool, default False\n         indicator whether the datetime string should be iso8601\n\n    Returns\n    -------\n    tuple (ndarray, tzoffset)\n    "
    ...

def astype_intsafe() -> typing.Any:
    ...

def clean_index_list() -> typing.Any:
    '\n    Utility used in ``pandas.core.indexes.api.ensure_index``.\n    '
    ...

def count_level_2d() -> typing.Any:
    ...

def dicts_to_array() -> typing.Any:
    ...

def ensure_string_array() -> typing.Any:
    "Returns a new numpy array with object dtype and only strings and na values.\n\n    Parameters\n    ----------\n    arr : array-like\n        The values to be converted to str, if needed.\n    na_value : Any, default np.nan\n        The value to use for na. For example, np.nan or pd.NA.\n    convert_na_value : bool, default True\n        If False, existing na values will be used unchanged in the new array.\n    copy : bool, default True\n        Whether to ensure that a new array is returned.\n    skipna : bool, default True\n        Whether or not to coerce nulls to their stringified form\n        (e.g. if False, NaN becomes 'nan').\n\n    Returns\n    -------\n    ndarray\n        An array with the input array's elements casted to str or nan-like.\n    "
    ...

def fast_multiget() -> typing.Any:
    ...

def fast_unique_multiple() -> typing.Any:
    '\n    Generate a list of unique values from a list of arrays.\n\n    Parameters\n    ----------\n    list : array-like\n        List of array-like objects.\n    sort : bool\n        Whether or not to sort the resulting unique list.\n\n    Returns\n    -------\n    list of unique values\n    '
    ...

def fast_unique_multiple_list() -> typing.Any:
    ...

def fast_unique_multiple_list_gen() -> typing.Any:
    '\n    Generate a list of unique values from a generator of lists.\n\n    Parameters\n    ----------\n    gen : generator object\n        Generator of lists from which the unique list is created.\n    sort : bool\n        Whether or not to sort the resulting unique list.\n\n    Returns\n    -------\n    list of unique values\n    '
    ...

def fast_zip() -> typing.Any:
    '\n    For zipping multiple ndarrays into an ndarray of tuples.\n    '
    ...

def generate_bins_dt64() -> typing.Any:
    '\n    Int64 (datetime64) version of generic python version in ``groupby.py``.\n    '
    ...

def generate_slices() -> typing.Any:
    ...

def get_level_sorter() -> typing.Any:
    "\n    Argsort for a single level of a multi-index, keeping the order of higher\n    levels unchanged. `starts` points to starts of same-key indices w.r.t\n    to leading levels; equivalent to:\n        np.hstack([label[starts[i]:starts[i+1]].argsort(kind='mergesort')\n            + starts[i] for i in range(len(starts) - 1)])\n    "
    ...

def get_reverse_indexer() -> typing.Any:
    '\n    Reverse indexing operation.\n\n    Given `indexer`, make `indexer_inv` of it, such that::\n\n        indexer_inv[indexer[x]] = x\n\n    .. note:: If indexer is not unique, only first occurrence is accounted.\n    '
    ...

def has_infs_f4() -> typing.Any:
    ...

def has_infs_f8() -> typing.Any:
    ...

def indices_fast() -> typing.Any:
    '\n    Parameters\n    ----------\n    index : ndarray\n    labels : ndarray[int64]\n    keys : list\n    sorted_labels : list[ndarray[int64]]\n    '
    ...

def infer_datetimelike_array() -> typing.Any:
    '\n    Infer if we have a datetime or timedelta array.\n    - date: we have *only* date and maybe strings, nulls\n    - datetime: we have *only* datetimes and maybe strings, nulls\n    - timedelta: we have *only* timedeltas and maybe strings, nulls\n    - nat: we do not have *any* date, datetimes or timedeltas, but do have\n      at least a NaT\n    - mixed: other objects (strings, a mix of tz-aware and tz-naive, or\n                            actual objects)\n\n    Parameters\n    ----------\n    arr : ndarray[object]\n\n    Returns\n    -------\n    str: {datetime, timedelta, date, nat, mixed}\n    '
    ...

def infer_dtype() -> typing.Any:
    "\n    Efficiently infer the type of a passed val, or list-like\n    array of values. Return a string describing the type.\n\n    Parameters\n    ----------\n    value : scalar, list, ndarray, or pandas type\n    skipna : bool, default True\n        Ignore NaN values when inferring the type.\n\n    Returns\n    -------\n    str\n        Describing the common type of the input data.\n    Results can include:\n\n    - string\n    - bytes\n    - floating\n    - integer\n    - mixed-integer\n    - mixed-integer-float\n    - decimal\n    - complex\n    - categorical\n    - boolean\n    - datetime64\n    - datetime\n    - date\n    - timedelta64\n    - timedelta\n    - time\n    - period\n    - mixed\n\n    Raises\n    ------\n    TypeError\n        If ndarray-like but cannot infer the dtype\n\n    Notes\n    -----\n    - 'mixed' is the catchall for anything that is not otherwise\n      specialized\n    - 'mixed-integer-float' are floats and integers\n    - 'mixed-integer' are integers mixed with non-integers\n\n    Examples\n    --------\n    >>> infer_dtype(['foo', 'bar'])\n    'string'\n\n    >>> infer_dtype(['a', np.nan, 'b'], skipna=True)\n    'string'\n\n    >>> infer_dtype(['a', np.nan, 'b'], skipna=False)\n    'mixed'\n\n    >>> infer_dtype([b'foo', b'bar'])\n    'bytes'\n\n    >>> infer_dtype([1, 2, 3])\n    'integer'\n\n    >>> infer_dtype([1, 2, 3.5])\n    'mixed-integer-float'\n\n    >>> infer_dtype([1.0, 2.0, 3.5])\n    'floating'\n\n    >>> infer_dtype(['a', 1])\n    'mixed-integer'\n\n    >>> infer_dtype([Decimal(1), Decimal(2.0)])\n    'decimal'\n\n    >>> infer_dtype([True, False])\n    'boolean'\n\n    >>> infer_dtype([True, False, np.nan])\n    'mixed'\n\n    >>> infer_dtype([pd.Timestamp('20130101')])\n    'datetime'\n\n    >>> infer_dtype([datetime.date(2013, 1, 1)])\n    'date'\n\n    >>> infer_dtype([np.datetime64('2013-01-01')])\n    'datetime64'\n\n    >>> infer_dtype([datetime.timedelta(0, 1, 1)])\n    'timedelta'\n\n    >>> infer_dtype(pd.Series(list('aabc')).astype('category'))\n    'categorical'\n    "
    ...

def is_bool() -> typing.Any:
    '\n    Return True if given object is boolean.\n\n    Returns\n    -------\n    bool\n    '
    ...

def is_bool_array() -> typing.Any:
    ...

def is_complex() -> typing.Any:
    '\n    Return True if given object is complex.\n\n    Returns\n    -------\n    bool\n    '
    ...

def is_date_array() -> typing.Any:
    ...

def is_datetime64_array() -> typing.Any:
    ...

def is_datetime_array() -> typing.Any:
    ...

def is_datetime_with_singletz_array() -> typing.Any:
    "\n    Check values have the same tzinfo attribute.\n    Doesn't check values are datetime-like types.\n    "
    ...

def is_decimal() -> typing.Any:
    ...

def is_float() -> typing.Any:
    '\n    Return True if given object is float.\n\n    Returns\n    -------\n    bool\n    '
    ...

def is_float_array() -> typing.Any:
    ...

def is_integer() -> typing.Any:
    '\n    Return True if given object is integer.\n\n    Returns\n    -------\n    bool\n    '
    ...

def is_integer_array() -> typing.Any:
    ...

def is_interval() -> typing.Any:
    ...

def is_interval_array() -> typing.Any:
    ...

def is_iterator() -> typing.Any:
    '\n    Check if the object is an iterator.\n\n    This is intended for generators, not list-like objects.\n\n    Parameters\n    ----------\n    obj : The object to check\n\n    Returns\n    -------\n    is_iter : bool\n        Whether `obj` is an iterator.\n\n    Examples\n    --------\n    >>> is_iterator((x for x in []))\n    True\n    >>> is_iterator([1, 2, 3])\n    False\n    >>> is_iterator(datetime(2017, 1, 1))\n    False\n    >>> is_iterator("foo")\n    False\n    >>> is_iterator(1)\n    False\n    '
    ...

def is_list_like() -> typing.Any:
    '\n    Check if the object is list-like.\n\n    Objects that are considered list-like are for example Python\n    lists, tuples, sets, NumPy arrays, and Pandas Series.\n\n    Strings and datetime objects, however, are not considered list-like.\n\n    Parameters\n    ----------\n    obj : object\n        Object to check.\n    allow_sets : bool, default True\n        If this parameter is False, sets will not be considered list-like.\n\n        .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    bool\n        Whether `obj` has list-like properties.\n\n    Examples\n    --------\n    >>> is_list_like([1, 2, 3])\n    True\n    >>> is_list_like({1, 2, 3})\n    True\n    >>> is_list_like(datetime(2017, 1, 1))\n    False\n    >>> is_list_like("foo")\n    False\n    >>> is_list_like(1)\n    False\n    >>> is_list_like(np.array([2]))\n    True\n    >>> is_list_like(np.array(2))\n    False\n    '
    ...

def is_period() -> typing.Any:
    '\n    Return True if given object is Period.\n\n    Returns\n    -------\n    bool\n    '
    ...

def is_period_array() -> typing.Any:
    ...

def is_scalar() -> typing.Any:
    '\n    Return True if given object is scalar.\n\n    Parameters\n    ----------\n    val : object\n        This includes:\n\n        - numpy array scalar (e.g. np.int64)\n        - Python builtin numerics\n        - Python builtin byte arrays and strings\n        - None\n        - datetime.datetime\n        - datetime.timedelta\n        - Period\n        - decimal.Decimal\n        - Interval\n        - DateOffset\n        - Fraction\n        - Number.\n\n    Returns\n    -------\n    bool\n        Return True if given object is scalar.\n\n    Examples\n    --------\n    >>> dt = datetime.datetime(2018, 10, 3)\n    >>> pd.api.types.is_scalar(dt)\n    True\n\n    >>> pd.api.types.is_scalar([2, 3])\n    False\n\n    >>> pd.api.types.is_scalar({0: 1, 2: 3})\n    False\n\n    >>> pd.api.types.is_scalar((0, 2))\n    False\n\n    pandas supports PEP 3141 numbers:\n\n    >>> from fractions import Fraction\n    >>> pd.api.types.is_scalar(Fraction(3, 5))\n    True\n    '
    ...

def is_string_array() -> typing.Any:
    ...

def is_time_array() -> typing.Any:
    ...

def is_timedelta_or_timedelta64_array() -> typing.Any:
    '\n    Infer with timedeltas and/or nat/none.\n    '
    ...

def item_from_zerodim() -> typing.Any:
    "\n    If the value is a zerodim array, return the item it contains.\n\n    Parameters\n    ----------\n    val : object\n\n    Returns\n    -------\n    object\n\n    Examples\n    --------\n    >>> item_from_zerodim(1)\n    1\n    >>> item_from_zerodim('foobar')\n    'foobar'\n    >>> item_from_zerodim(np.array(1))\n    1\n    >>> item_from_zerodim(np.array([1]))\n    array([1])\n    "
    ...

def map_infer() -> typing.Any:
    '\n    Substitute for np.vectorize with pandas-friendly dtype inference.\n\n    Parameters\n    ----------\n    arr : ndarray\n    f : function\n    convert : bint\n    ignore_na : bint\n        If True, NA values will not have f applied\n\n    Returns\n    -------\n    ndarray\n    '
    ...

def map_infer_mask() -> typing.Any:
    '\n    Substitute for np.vectorize with pandas-friendly dtype inference.\n\n    Parameters\n    ----------\n    arr : ndarray\n    f : function\n    mask : ndarray\n        uint8 dtype ndarray indicating values not to apply `f` to.\n    convert : bool, default True\n        Whether to call `maybe_convert_objects` on the resulting ndarray\n    na_value : Any, optional\n        The result value to use for masked values. By default, the\n        input value is used\n    dtype : numpy.dtype\n        The numpy dtype to use for the result ndarray.\n\n    Returns\n    -------\n    ndarray\n    '
    ...

def maybe_booleans_to_slice() -> typing.Any:
    ...

def maybe_convert_numeric() -> typing.Any:
    "\n    Convert object array to a numeric array if possible.\n\n    Parameters\n    ----------\n    values : ndarray\n        Array of object elements to convert.\n    na_values : set\n        Set of values that should be interpreted as NaN.\n    convert_empty : bool, default True\n        If an empty array-like object is encountered, whether to interpret\n        that element as NaN or not. If set to False, a ValueError will be\n        raised if such an element is encountered and 'coerce_numeric' is False.\n    coerce_numeric : bool, default False\n        If initial attempts to convert to numeric have failed, whether to\n        force conversion to numeric via alternative methods or by setting the\n        element to NaN. Otherwise, an Exception will be raised when such an\n        element is encountered.\n\n        This boolean also has an impact on how conversion behaves when a\n        numeric array has no suitable numerical dtype to return (i.e. uint64,\n        int32, uint8). If set to False, the original object array will be\n        returned. Otherwise, a ValueError will be raised.\n\n    Returns\n    -------\n    Array of converted object values to numerical ones.\n    "
    ...

def maybe_convert_objects() -> typing.Any:
    '\n    Type inference function-- convert object array to proper dtype\n\n    Parameters\n    ----------\n    values : ndarray\n        Array of object elements to convert.\n    try_float : bool, default False\n        If an array-like object contains only float or NaN values is\n        encountered, whether to convert and return an array of float dtype.\n    safe : bool, default False\n        Whether to upcast numeric type (e.g. int cast to float). If set to\n        True, no upcasting will be performed.\n    convert_datetime : bool, default False\n        If an array-like object contains only datetime values or NaT is\n        encountered, whether to convert and return an array of M8[ns] dtype.\n    convert_timedelta : bool, default False\n        If an array-like object contains only timedelta values or NaT is\n        encountered, whether to convert and return an array of m8[ns] dtype.\n    convert_to_nullable_integer : bool, default False\n        If an array-like object contains only integer values (and NaN) is\n        encountered, whether to convert and return an IntegerArray.\n\n    Returns\n    -------\n    Array of converted object values to more specific dtypes if applicable.\n    '
    ...

def maybe_indices_to_slice() -> typing.Any:
    ...

def memory_usage_of_objects() -> typing.Any:
    '\n    Return the memory usage of an object array in bytes.\n\n    Does not include the actual bytes of the pointers\n    '
    ...

no_default: object
def to_object_array() -> typing.Any:
    '\n    Convert a list of lists into an object array.\n\n    Parameters\n    ----------\n    rows : 2-d array (N, K)\n        List of lists to be converted into an array.\n    min_width : int\n        Minimum width of the object array. If a list\n        in `rows` contains fewer than `width` elements,\n        the remaining elements in the corresponding row\n        will all be `NaN`.\n\n    Returns\n    -------\n    numpy array of the object dtype.\n    '
    ...

def to_object_array_tuples() -> typing.Any:
    '\n    Convert a list of tuples into an object array. Any subclass of\n    tuple in `rows` will be casted to tuple.\n\n    Parameters\n    ----------\n    rows : 2-d array (N, K)\n        List of tuples to be converted into an array.\n\n    Returns\n    -------\n    numpy array of the object dtype.\n    '
    ...

def tuples_to_object_array() -> typing.Any:
    ...

def __getattr__(name) -> typing.Any:
    ...

