'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var n = require('melody-types');
var he = require('he');
var trimEnd = _interopDefault(require('lodash/trimEnd'));
var trimStart = _interopDefault(require('lodash/trimStart'));
var codeFrame = _interopDefault(require('melody-code-frame'));

var _ERROR_TABLE;

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var EXPRESSION_START = 'expressionStart';
var EXPRESSION_END = 'expressionEnd';
var TAG_START = 'tagStart';
var TAG_END = 'tagEnd';
var INTERPOLATION_START = 'interpolationStart';
var INTERPOLATION_END = 'interpolationEnd';
var STRING_START = 'stringStart';
var STRING_END = 'stringEnd';
var DECLARATION_START = 'declarationStart';
var COMMENT = 'comment';
var WHITESPACE = 'whitespace';
var HTML_COMMENT = 'htmlComment';
var TEXT = 'text';
var ENTITY = 'entity';
var SYMBOL = 'symbol';
var STRING = 'string';
var OPERATOR = 'operator';
var TRUE = 'true';
var FALSE = 'false';
var NULL = 'null';
var LBRACE = '[';
var RBRACE = ']';
var LPAREN = '(';
var RPAREN = ')';
var LBRACKET = '{';
var RBRACKET = '}';
var COLON = ':';
var COMMA = ',';
var DOT = '.';
var PIPE = '|';
var QUESTION_MARK = '?';
var ASSIGNMENT = '=';
var ELEMENT_START = '<';
var SLASH = '/';
var ELEMENT_END = '>';
var NUMBER = 'number';
var EOF = 'EOF';
var ERROR = 'ERROR';
var EOF_TOKEN = {
    type: EOF,
    pos: {
        index: -1,
        line: -1,
        pos: -1
    },
    end: -1,
    length: 0,
    source: null,
    text: ''
};

var ERROR_TABLE = (_ERROR_TABLE = {}, _ERROR_TABLE[EXPRESSION_END] = 'expression end "}}"', _ERROR_TABLE[EXPRESSION_START] = 'expression start "{{"', _ERROR_TABLE[TAG_START] = 'tag start "{%"', _ERROR_TABLE[TAG_END] = 'tag end "%}"', _ERROR_TABLE[INTERPOLATION_START] = 'interpolation start "#{"', _ERROR_TABLE[INTERPOLATION_END] = 'interpolation end "}"', _ERROR_TABLE);

var TokenTypes = /*#__PURE__*/Object.freeze({
    EXPRESSION_START: EXPRESSION_START,
    EXPRESSION_END: EXPRESSION_END,
    TAG_START: TAG_START,
    TAG_END: TAG_END,
    INTERPOLATION_START: INTERPOLATION_START,
    INTERPOLATION_END: INTERPOLATION_END,
    STRING_START: STRING_START,
    STRING_END: STRING_END,
    DECLARATION_START: DECLARATION_START,
    COMMENT: COMMENT,
    WHITESPACE: WHITESPACE,
    HTML_COMMENT: HTML_COMMENT,
    TEXT: TEXT,
    ENTITY: ENTITY,
    SYMBOL: SYMBOL,
    STRING: STRING,
    OPERATOR: OPERATOR,
    TRUE: TRUE,
    FALSE: FALSE,
    NULL: NULL,
    LBRACE: LBRACE,
    RBRACE: RBRACE,
    LPAREN: LPAREN,
    RPAREN: RPAREN,
    LBRACKET: LBRACKET,
    RBRACKET: RBRACKET,
    COLON: COLON,
    COMMA: COMMA,
    DOT: DOT,
    PIPE: PIPE,
    QUESTION_MARK: QUESTION_MARK,
    ASSIGNMENT: ASSIGNMENT,
    ELEMENT_START: ELEMENT_START,
    SLASH: SLASH,
    ELEMENT_END: ELEMENT_END,
    NUMBER: NUMBER,
    EOF: EOF,
    ERROR: ERROR,
    EOF_TOKEN: EOF_TOKEN,
    ERROR_TABLE: ERROR_TABLE
});

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var LEFT = Symbol();
var RIGHT = Symbol();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function setStartFromToken(node, _ref) {
    var _ref$pos = _ref.pos,
        index = _ref$pos.index,
        line = _ref$pos.line,
        column = _ref$pos.column;

    node.loc.start = { line: line, column: column, index: index };
    return node;
}

function setEndFromToken(node, _ref2) {
    var _ref2$pos = _ref2.pos,
        line = _ref2$pos.line,
        column = _ref2$pos.column,
        end = _ref2.end;

    node.loc.end = { line: line, column: column, index: end };
    return node;
}

function setMarkFromToken(node, propertyName, _ref3) {
    var _ref3$pos = _ref3.pos,
        index = _ref3$pos.index,
        line = _ref3$pos.line,
        column = _ref3$pos.column;

    node[propertyName] = { line: line, column: column, index: index };
    return node;
}

function copyStart(node, _ref4) {
    var _ref4$loc$start = _ref4.loc.start,
        line = _ref4$loc$start.line,
        column = _ref4$loc$start.column,
        index = _ref4$loc$start.index;

    node.loc.start.line = line;
    node.loc.start.column = column;
    node.loc.start.index = index;
    return node;
}

function copyEnd(node, end) {
    node.loc.end.line = end.loc.end.line;
    node.loc.end.column = end.loc.end.column;
    node.loc.end.index = end.loc.end.index;
    return node;
}

function getNodeSource(node, entireSource) {
    if (entireSource && node.loc.start && node.loc.end) {
        return entireSource.substring(node.loc.start.index, node.loc.end.index);
    }
    return '';
}

function copyLoc(node, _ref5) {
    var _ref5$loc = _ref5.loc,
        start = _ref5$loc.start,
        end = _ref5$loc.end;

    node.loc.start.line = start.line;
    node.loc.start.column = start.column;
    node.loc.start.index = start.index;
    node.loc.end.line = end.line;
    node.loc.end.column = end.column;
    node.loc.end.index = end.index;
    return node;
}

function createNode(Type, token) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
    }

    return setEndFromToken(setStartFromToken(new (Function.prototype.bind.apply(Type, [null].concat(args)))(), token), token);
}

function hasTagStartTokenTrimLeft(token) {
    return token.text.endsWith('-');
}

function hasTagEndTokenTrimRight(token) {
    return token.text.startsWith('-');
}

function isMelodyExtension(obj) {
    return obj && (Array.isArray(obj.binaryOperators) || _typeof(obj.filterMap) === 'object' || _typeof(obj.functionMap) === 'object' || Array.isArray(obj.tags) || Array.isArray(obj.tests) || Array.isArray(obj.unaryOperators) || Array.isArray(obj.visitors));
}

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var GenericTagParser = {
    name: 'genericTwigTag',
    parse: function parse(parser) {
        var tokens = parser.tokens,
            tagStartToken = tokens.la(-2);
        var currentToken = void 0;

        var twigTag = new n.GenericTwigTag(tokens.la(-1).text);
        while (currentToken = tokens.la(0)) {
            if (currentToken.type === TAG_END) {
                break;
            } else {
                try {
                    twigTag.parts.push(parser.matchExpression());
                } catch (e) {
                    if (e.errorType === 'UNEXPECTED_TOKEN') {
                        twigTag.parts.push(new n.GenericToken(e.tokenType, e.tokenText));
                        tokens.next();
                    } else {
                        throw e;
                    }
                }
            }
        }
        tokens.expect(TAG_END);

        twigTag.trimLeft = hasTagStartTokenTrimLeft(tagStartToken);
        twigTag.trimRight = hasTagEndTokenTrimRight(currentToken);

        return twigTag;
    }
};

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var tagMatchesOneOf = function tagMatchesOneOf(tokenStream, tagNames) {
    for (var i = 0; i < tagNames.length; i++) {
        if (tokenStream.test(SYMBOL, tagNames[i])) {
            return true;
        }
    }
    return false;
};

var createMultiTagParser = function createMultiTagParser(tagName) {
    var subTags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return {
        name: 'genericTwigMultiTag',
        parse: function parse(parser, token) {
            var tokens = parser.tokens,
                tagStartToken = tokens.la(-1);

            if (subTags.length === 0) {
                subTags.push('end' + tagName);
            }

            var twigTag = GenericTagParser.parse(parser, token);
            var currentTagName = tagName;
            var endTagName = subTags[subTags.length - 1];

            while (currentTagName !== endTagName) {
                // Parse next section
                twigTag.sections.push(parser.parse(function (tokenText, token, tokens) {
                    var hasReachedNextTag = token.type === TAG_START && tagMatchesOneOf(tokens, subTags);
                    return hasReachedNextTag;
                }));
                tokens.next(); // Get past "{%"

                // Parse next tag
                var childTag = GenericTagParser.parse(parser);
                twigTag.sections.push(childTag);
                currentTagName = childTag.tagName;
            }

            setStartFromToken(twigTag, tagStartToken);
            setEndFromToken(twigTag, tokens.la(0));

            return twigTag;
        }
    };
};

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// https://www.w3.org/TR/html5/syntax.html#void-elements
var voidElements = {
    area: true,
    base: true,
    br: true,
    col: true,
    embed: true,
    hr: true,
    img: true,
    input: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
};

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var UNARY = Symbol(),
    BINARY = Symbol(),
    TAG = Symbol(),
    TEST = Symbol();

var Parser = function () {
    function Parser(tokenStream, options) {
        classCallCheck(this, Parser);

        this.tokens = tokenStream;
        this[UNARY] = {};
        this[BINARY] = {};
        this[TAG] = {};
        this[TEST] = {};
        this.options = Object.assign({}, {
            ignoreComments: true,
            ignoreHtmlComments: true,
            ignoreDeclarations: true,
            decodeEntities: true,
            preserveSourceLiterally: false,
            allowUnknownTags: false,
            multiTags: {} // e.g. { "nav": ["endnav"], "switch": ["case", "default", "endswitch"]}
        }, options);
        // If there are custom multi tags, then we allow all custom tags
        if (Object.keys(this.options.multiTags).length > 0) {
            this.options.allowUnknownTags = true;
        }
    }

    Parser.prototype.applyExtension = function applyExtension(ext) {
        if (ext.tags) {
            for (var _iterator = ext.tags, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                var tag = _ref;

                this.addTag(tag);
            }
        }
        if (ext.unaryOperators) {
            for (var _iterator2 = ext.unaryOperators, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
                var _ref2;

                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done) break;
                    _ref2 = _i2.value;
                }

                var op = _ref2;

                this.addUnaryOperator(op);
            }
        }
        if (ext.binaryOperators) {
            for (var _iterator3 = ext.binaryOperators, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
                var _ref3;

                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    _i3 = _iterator3.next();
                    if (_i3.done) break;
                    _ref3 = _i3.value;
                }

                var _op = _ref3;

                this.addBinaryOperator(_op);
            }
        }
        if (ext.tests) {
            for (var _iterator4 = ext.tests, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
                var _ref4;

                if (_isArray4) {
                    if (_i4 >= _iterator4.length) break;
                    _ref4 = _iterator4[_i4++];
                } else {
                    _i4 = _iterator4.next();
                    if (_i4.done) break;
                    _ref4 = _i4.value;
                }

                var test = _ref4;

                this.addTest(test);
            }
        }
    };

    Parser.prototype.addUnaryOperator = function addUnaryOperator(op) {
        this[UNARY][op.text] = op;
        return this;
    };

    Parser.prototype.addBinaryOperator = function addBinaryOperator(op) {
        this[BINARY][op.text] = op;
        return this;
    };

    Parser.prototype.addTag = function addTag(tag) {
        this[TAG][tag.name] = tag;
        return this;
    };

    Parser.prototype.addTest = function addTest(test) {
        this[TEST][test.text] = test;
    };

    Parser.prototype.hasTest = function hasTest(test) {
        return !!this[TEST][test];
    };

    Parser.prototype.getTest = function getTest(test) {
        return this[TEST][test];
    };

    Parser.prototype.isUnary = function isUnary(token) {
        return token.type === OPERATOR && !!this[UNARY][token.text];
    };

    Parser.prototype.getBinaryOperator = function getBinaryOperator(token) {
        return token.type === OPERATOR && this[BINARY][token.text];
    };

    Parser.prototype.parse = function parse() {
        var test = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        var tokens = this.tokens,
            p = setStartFromToken(new n.SequenceExpression(), tokens.la(0));
        while (!tokens.test(EOF)) {
            var token = tokens.next();
            if (!p) {
                p = setStartFromToken(new n.SequenceExpression(), token);
            }
            if (test && test(tokens.la(0).text, token, tokens)) {
                setEndFromToken(p, token);
                return p;
            }
            switch (token.type) {
                case EXPRESSION_START:
                    {
                        var expression = this.matchExpression();
                        var statement = new n.PrintExpressionStatement(expression);
                        var endToken = tokens.expect(EXPRESSION_END);
                        setStartFromToken(statement, token);
                        setEndFromToken(statement, endToken);
                        setEndFromToken(p, endToken);
                        statement.trimLeft = !!expression.trimLeft;
                        statement.trimRight = !!expression.trimRight;
                        p.add(statement);

                        break;
                    }
                case TAG_START:
                    p.add(this.matchTag());
                    break;
                case TEXT:
                    {
                        var textStringLiteral = createNode(n.StringLiteral, token, token.text);
                        var textTextStatement = createNode(n.PrintTextStatement, token, textStringLiteral);
                        p.add(textTextStatement);
                        break;
                    }
                case ENTITY:
                    {
                        var entityStringLiteral = createNode(n.StringLiteral, token, !this.options.decodeEntities || this.options.preserveSourceLiterally ? token.text : he.decode(token.text));
                        var entityTextStatement = createNode(n.PrintTextStatement, token, entityStringLiteral);
                        p.add(entityTextStatement);
                        break;
                    }
                case ELEMENT_START:
                    p.add(this.matchElement());
                    break;
                case DECLARATION_START:
                    {
                        var declarationNode = this.matchDeclaration();
                        if (!this.options.ignoreDeclarations) {
                            p.add(declarationNode);
                        }
                        break;
                    }
                case COMMENT:
                    if (!this.options.ignoreComments) {
                        var stringLiteral = createNode(n.StringLiteral, token, token.text);
                        var twigComment = createNode(n.TwigComment, token, stringLiteral);
                        p.add(twigComment);
                    }
                    break;
                case HTML_COMMENT:
                    if (!this.options.ignoreHtmlComments) {
                        var _stringLiteral = createNode(n.StringLiteral, token, token.text);
                        var htmlComment = createNode(n.HtmlComment, token, _stringLiteral);
                        p.add(htmlComment);
                    }
                    break;
            }
        }
        return p;
    };

    /**
     * e.g., <!DOCTYPE html>
     */


    Parser.prototype.matchDeclaration = function matchDeclaration() {
        var tokens = this.tokens,
            declarationStartToken = tokens.la(-1);
        var declarationType = null,
            currentToken = null;

        if (!(declarationType = tokens.nextIf(SYMBOL))) {
            this.error({
                title: 'Expected declaration start',
                pos: declarationStartToken.pos,
                advice: "After '<!', an unquoted symbol like DOCTYPE is expected"
            });
        }

        var declaration = new n.Declaration(declarationType.text);
        while (currentToken = tokens.next()) {
            if (currentToken.type === SYMBOL) {
                var symbol = createNode(n.Identifier, currentToken, currentToken.text);
                declaration.parts.push(symbol);
            } else if (currentToken.type === STRING_START) {
                var stringToken = tokens.expect(STRING);
                declaration.parts.push(createNode(n.StringLiteral, stringToken, stringToken.text));
                tokens.expect(STRING_END);
            } else if (currentToken.type === EXPRESSION_START) {
                var expression = this.matchExpression();
                declaration.parts.push(copyLoc(new n.PrintExpressionStatement(expression), expression));
                tokens.expect(EXPRESSION_END);
            } else if (currentToken.type === ELEMENT_END) {
                break;
            } else {
                this.error({
                    title: 'Expected string, symbol, or expression',
                    pos: currentToken.pos,
                    advice: 'Only strings or symbols can be part of a declaration'
                });
            }
        }
        setStartFromToken(declaration, declarationStartToken);
        setEndFromToken(declaration, currentToken);

        return declaration;
    };

    /**
     * matchElement = '<' SYMBOL attributes* '/'? '>' (children)* '<' '/' SYMBOL '>'
     * attributes = SYMBOL '=' (matchExpression | matchString)
     *              | matchExpression
     */


    Parser.prototype.matchElement = function matchElement() {
        var tokens = this.tokens,
            elementNameToken = tokens.la(0),
            tagStartToken = tokens.la(-1);
        var elementName = void 0;
        if (!(elementName = tokens.nextIf(SYMBOL))) {
            this.error({
                title: 'Expected element start',
                pos: elementNameToken.pos,
                advice: tokens.lat(0) === SLASH ? 'Unexpected closing "' + tokens.la(1).text + '" tag. Seems like your DOM is out of control.' : 'Expected an element to start'
            });
        }

        var element = new n.Element(elementName.text);

        this.matchAttributes(element, tokens);

        if (tokens.nextIf(SLASH)) {
            tokens.expect(ELEMENT_END);
            element.selfClosing = true;
        } else {
            tokens.expect(ELEMENT_END);
            if (voidElements[elementName.text]) {
                element.selfClosing = true;
            } else {
                element.children = this.parse(function (_, token, tokens) {
                    if (token.type === ELEMENT_START && tokens.lat(0) === SLASH) {
                        var name = tokens.la(1);
                        if (name.type === SYMBOL && name.text === elementName.text) {
                            tokens.next(); // SLASH
                            tokens.next(); // elementName
                            tokens.expect(ELEMENT_END);
                            return true;
                        }
                    }
                    return false;
                }).expressions;
            }
        }

        setStartFromToken(element, tagStartToken);
        setEndFromToken(element, tokens.la(-1));
        setMarkFromToken(element, 'elementNameLoc', elementNameToken);

        return element;
    };

    Parser.prototype.matchAttributes = function matchAttributes(element, tokens) {
        while (tokens.lat(0) !== SLASH && tokens.lat(0) !== ELEMENT_END) {
            var key = tokens.nextIf(SYMBOL);
            if (key) {
                var keyNode = new n.Identifier(key.text);
                setStartFromToken(keyNode, key);
                setEndFromToken(keyNode, key);

                // match an attribute
                if (tokens.nextIf(ASSIGNMENT)) {
                    var start = tokens.expect(STRING_START);
                    var canBeString = true,
                        nodes = [],
                        token = void 0;
                    while (!tokens.test(STRING_END)) {
                        if (canBeString && (token = tokens.nextIf(STRING))) {
                            nodes[nodes.length] = createNode(n.StringLiteral, token, token.text);
                            canBeString = false;
                        } else if (token = tokens.nextIf(EXPRESSION_START)) {
                            nodes[nodes.length] = this.matchExpression();
                            tokens.expect(EXPRESSION_END);
                            canBeString = true;
                        } else {
                            break;
                        }
                    }
                    tokens.expect(STRING_END);
                    if (!nodes.length) {
                        var node = createNode(n.StringLiteral, start, '');
                        nodes.push(node);
                    }

                    var expr = nodes[0];
                    for (var i = 1, len = nodes.length; i < len; i++) {
                        var _expr$loc$start = expr.loc.start,
                            line = _expr$loc$start.line,
                            column = _expr$loc$start.column;

                        expr = new n.BinaryConcatExpression(expr, nodes[i]);
                        expr.loc.start.line = line;
                        expr.loc.start.column = column;
                        copyEnd(expr, expr.right);
                    }
                    // Distinguish between BinaryConcatExpression generated by
                    // this Parser (implicit before parsing), and those that the
                    // user wrote explicitly.
                    if (nodes.length > 1) {
                        expr.wasImplicitConcatenation = true;
                    }
                    var attr = new n.Attribute(keyNode, expr);
                    copyStart(attr, keyNode);
                    copyEnd(attr, expr);
                    element.attributes.push(attr);
                } else {
                    element.attributes.push(copyLoc(new n.Attribute(keyNode), keyNode));
                }
            } else if (tokens.nextIf(EXPRESSION_START)) {
                element.attributes.push(this.matchExpression());
                tokens.expect(EXPRESSION_END);
            } else {
                this.error({
                    title: 'Invalid token',
                    pos: tokens.la(0).pos,
                    advice: 'A tag must consist of attributes or expressions. Twig Tags are not allowed.'
                });
            }
        }
    };

    Parser.prototype.error = function error(options) {
        var metadata = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        this.tokens.error(options.title, options.pos, options.advice, 1, metadata);
    };

    Parser.prototype.getGenericParserFor = function getGenericParserFor(tagName) {
        if (this.options.multiTags[tagName]) {
            return createMultiTagParser(tagName, this.options.multiTags[tagName]);
        } else {
            return GenericTagParser;
        }
    };

    Parser.prototype.matchTag = function matchTag() {
        var tokens = this.tokens;
        var tagStartToken = tokens.la(-1);

        var tag = tokens.expect(SYMBOL);
        var parser = this[TAG][tag.text];
        var isUsingGenericParser = false;
        if (!parser) {
            if (this.options.allowUnknownTags) {
                parser = this.getGenericParserFor(tag.text);
                isUsingGenericParser = true;
            } else {
                tokens.error('Unknown tag "' + tag.text + '"', tag.pos, 'Expected a known tag such as\n- ' + Object.getOwnPropertyNames(this[TAG]).join('\n- '), tag.length);
            }
        }

        var result = parser.parse(this, tag);
        var tagEndToken = tokens.la(-1);
        if (!isUsingGenericParser) {
            result.trimLeft = tagStartToken.text.endsWith('-');
            result.trimRight = tagEndToken.text.startsWith('-');
        }

        setStartFromToken(result, tagStartToken);
        setEndFromToken(result, tagEndToken);
        setMarkFromToken(result, 'tagNameLoc', tag);

        return result;
    };

    Parser.prototype.matchExpression = function matchExpression() {
        var precedence = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        var tokens = this.tokens,
            exprStartToken = tokens.la(0);
        var token = void 0,
            op = void 0,
            trimLeft = false;

        // Check for {{- (trim preceding whitespace)
        if (tokens.la(-1).type === EXPRESSION_START && tokens.la(-1).text.endsWith('-')) {
            trimLeft = true;
        }

        var expr = this.getPrimary();
        while ((token = tokens.la(0)) && token.type !== EOF && (op = this.getBinaryOperator(token)) && op.precedence >= precedence) {
            var opToken = tokens.next(); // consume the operator
            if (op.parse) {
                expr = op.parse(this, opToken, expr);
            } else {
                var expr1 = this.matchExpression(op.associativity === LEFT ? op.precedence + 1 : op.precedence);
                expr = op.createNode(token, expr, expr1);
            }
            token = tokens.la(0);
        }

        var result = expr;
        if (precedence === 0) {
            setEndFromToken(expr, tokens.la(-1));
            result = this.matchConditionalExpression(expr);
            // Update the local token variable because the stream pointer already advanced.
            token = tokens.la(0);
        }

        // Check for -}} (trim following whitespace)
        if (token.type === EXPRESSION_END && token.text.startsWith('-')) {
            result.trimRight = true;
        }
        if (trimLeft) {
            result.trimLeft = trimLeft;
        }

        var exprEndToken = tokens.la(-1);
        setStartFromToken(result, exprStartToken);
        setEndFromToken(result, exprEndToken);

        return result;
    };

    Parser.prototype.getPrimary = function getPrimary() {
        var tokens = this.tokens,
            token = tokens.la(0);
        if (this.isUnary(token)) {
            var op = this[UNARY][token.text];
            tokens.next(); // consume operator
            var expr = this.matchExpression(op.precedence);
            return this.matchPostfixExpression(op.createNode(token, expr));
        } else if (tokens.test(LPAREN)) {
            tokens.next(); // consume '('
            var _expr = this.matchExpression();
            tokens.expect(RPAREN);
            return this.matchPostfixExpression(_expr);
        }

        return this.matchPrimaryExpression();
    };

    Parser.prototype.matchPrimaryExpression = function matchPrimaryExpression() {
        var tokens = this.tokens,
            token = tokens.la(0),
            node = void 0;
        switch (token.type) {
            case NULL:
                node = createNode(n.NullLiteral, tokens.next());
                break;
            case FALSE:
                node = createNode(n.BooleanLiteral, tokens.next(), false);
                break;
            case TRUE:
                node = createNode(n.BooleanLiteral, tokens.next(), true);
                break;
            case SYMBOL:
                tokens.next();
                if (tokens.test(LPAREN)) {
                    // SYMBOL '(' arguments* ')'
                    node = new n.CallExpression(createNode(n.Identifier, token, token.text), this.matchArguments());
                    copyStart(node, node.callee);
                    setEndFromToken(node, tokens.la(-1)); // ')'
                } else {
                    node = createNode(n.Identifier, token, token.text);
                }
                break;
            case NUMBER:
                node = createNode(n.NumericLiteral, token, Number(tokens.next()));
                break;
            case STRING_START:
                node = this.matchStringExpression();
                break;
            // potentially missing: OPERATOR type
            default:
                if (token.type === LBRACE) {
                    node = this.matchArray();
                } else if (token.type === LBRACKET) {
                    node = this.matchMap();
                } else {
                    this.error({
                        title: 'Unexpected token "' + token.type + '" of value "' + token.text + '"',
                        pos: token.pos
                    }, {
                        errorType: 'UNEXPECTED_TOKEN',
                        tokenText: token.text,
                        tokenType: token.type
                    });
                }
                break;
        }

        return this.matchPostfixExpression(node);
    };

    Parser.prototype.matchStringExpression = function matchStringExpression() {
        var canBeString = true,
            token = void 0;
        var tokens = this.tokens,
            nodes = [],
            stringStart = tokens.expect(STRING_START);
        while (!tokens.test(STRING_END)) {
            if (canBeString && (token = tokens.nextIf(STRING))) {
                nodes[nodes.length] = createNode(n.StringLiteral, token, token.text);
                canBeString = false;
            } else if (token = tokens.nextIf(INTERPOLATION_START)) {
                nodes[nodes.length] = this.matchExpression();
                tokens.expect(INTERPOLATION_END);
                canBeString = true;
            } else {
                break;
            }
        }
        var stringEnd = tokens.expect(STRING_END);

        if (!nodes.length) {
            return setEndFromToken(createNode(n.StringLiteral, stringStart, ''), stringEnd);
        }

        var expr = nodes[0];
        for (var i = 1, len = nodes.length; i < len; i++) {
            var _expr$loc$start2 = expr.loc.start,
                line = _expr$loc$start2.line,
                column = _expr$loc$start2.column;

            expr = new n.BinaryConcatExpression(expr, nodes[i]);
            expr.loc.start.line = line;
            expr.loc.start.column = column;
            copyEnd(expr, expr.right);
        }

        if (nodes.length > 1) {
            expr.wasImplicitConcatenation = true;
        }

        setStartFromToken(expr, stringStart);
        setEndFromToken(expr, stringEnd);

        return expr;
    };

    Parser.prototype.matchConditionalExpression = function matchConditionalExpression(test) {
        var tokens = this.tokens;
        var condition = test,
            consequent = void 0,
            alternate = void 0;
        while (tokens.nextIf(QUESTION_MARK)) {
            if (!tokens.nextIf(COLON)) {
                consequent = this.matchExpression();
                if (tokens.nextIf(COLON)) {
                    alternate = this.matchExpression();
                } else {
                    alternate = null;
                }
            } else {
                consequent = null;
                alternate = this.matchExpression();
            }
            var _condition$loc$start = condition.loc.start,
                line = _condition$loc$start.line,
                column = _condition$loc$start.column;

            condition = new n.ConditionalExpression(condition, consequent, alternate);
            condition.loc.start = { line: line, column: column };
            copyEnd(condition, alternate || consequent);
        }
        return condition;
    };

    Parser.prototype.matchArray = function matchArray() {
        var tokens = this.tokens,
            array = new n.ArrayExpression(),
            start = tokens.expect(LBRACE);
        setStartFromToken(array, start);
        while (!tokens.test(RBRACE) && !tokens.test(EOF)) {
            array.elements.push(this.matchExpression());
            if (!tokens.test(RBRACE)) {
                tokens.expect(COMMA);
                // support trailing commas
                if (tokens.test(RBRACE)) {
                    break;
                }
            }
        }
        setEndFromToken(array, tokens.expect(RBRACE));
        return array;
    };

    Parser.prototype.matchMap = function matchMap() {
        var tokens = this.tokens,
            token = void 0,
            obj = new n.ObjectExpression(),
            startToken = tokens.expect(LBRACKET);
        setStartFromToken(obj, startToken);
        while (!tokens.test(RBRACKET) && !tokens.test(EOF)) {
            var computed = false,
                key = void 0,
                value = void 0;
            if (tokens.test(STRING_START)) {
                key = this.matchStringExpression();
                if (!n.is(key, 'StringLiteral')) {
                    computed = true;
                }
            } else if (token = tokens.nextIf(SYMBOL)) {
                key = createNode(n.Identifier, token, token.text);
            } else if (token = tokens.nextIf(NUMBER)) {
                key = createNode(n.NumericLiteral, token, Number(token.text));
            } else if (tokens.test(LPAREN)) {
                key = this.matchExpression();
                computed = true;
            } else {
                this.error({
                    title: 'Invalid map key',
                    pos: tokens.la(0).pos,
                    advice: 'Key must be a string, symbol or a number but was ' + tokens.next()
                });
            }
            tokens.expect(COLON);
            value = this.matchExpression();
            var prop = new n.ObjectProperty(key, value, computed);
            copyStart(prop, key);
            copyEnd(prop, value);
            obj.properties.push(prop);
            if (!tokens.test(RBRACKET)) {
                tokens.expect(COMMA);
                // support trailing comma
                if (tokens.test(RBRACKET)) {
                    break;
                }
            }
        }
        setEndFromToken(obj, tokens.expect(RBRACKET));
        return obj;
    };

    Parser.prototype.matchPostfixExpression = function matchPostfixExpression(expr) {
        var tokens = this.tokens;
        var node = expr;
        while (!tokens.test(EOF)) {
            if (tokens.test(DOT) || tokens.test(LBRACE)) {
                node = this.matchSubscriptExpression(node);
            } else if (tokens.test(PIPE)) {
                tokens.next();
                node = this.matchFilterExpression(node);
            } else {
                break;
            }
        }

        return node;
    };

    Parser.prototype.matchSubscriptExpression = function matchSubscriptExpression(node) {
        var tokens = this.tokens,
            op = tokens.next();
        if (op.type === DOT) {
            var token = tokens.next(),
                computed = false,
                property = void 0;
            if (token.type === SYMBOL) {
                property = createNode(n.Identifier, token, token.text);
            } else if (token.type === NUMBER) {
                property = createNode(n.NumericLiteral, token, Number(token.text));
                computed = true;
            } else {
                this.error({
                    title: 'Invalid token',
                    pos: token.pos,
                    advice: 'Expected number or symbol, found ' + token + ' instead'
                });
            }

            var memberExpr = new n.MemberExpression(node, property, computed);
            copyStart(memberExpr, node);
            copyEnd(memberExpr, property);
            if (tokens.test(LPAREN)) {
                var callExpr = new n.CallExpression(memberExpr, this.matchArguments());
                copyStart(callExpr, memberExpr);
                setEndFromToken(callExpr, tokens.la(-1));
                return callExpr;
            }
            return memberExpr;
        } else {
            var arg = void 0,
                start = void 0;
            if (tokens.test(COLON)) {
                // slice
                tokens.next();
                start = null;
            } else {
                arg = this.matchExpression();
                if (tokens.test(COLON)) {
                    start = arg;
                    arg = null;
                    tokens.next();
                }
            }

            if (arg) {
                return setEndFromToken(copyStart(new n.MemberExpression(node, arg, true), node), tokens.expect(RBRACE));
            } else {
                // slice
                var result = new n.SliceExpression(node, start, tokens.test(RBRACE) ? null : this.matchExpression());
                copyStart(result, node);
                setEndFromToken(result, tokens.expect(RBRACE));
                return result;
            }
        }
    };

    Parser.prototype.matchFilterExpression = function matchFilterExpression(node) {
        var tokens = this.tokens,
            target = node;
        while (!tokens.test(EOF)) {
            var token = tokens.expect(SYMBOL),
                name = createNode(n.Identifier, token, token.text),
                args = void 0;
            if (tokens.test(LPAREN)) {
                args = this.matchArguments();
            } else {
                args = [];
            }
            var newTarget = new n.FilterExpression(target, name, args);
            copyStart(newTarget, target);
            if (newTarget.arguments.length) {
                copyEnd(newTarget, newTarget.arguments[newTarget.arguments.length - 1]);
            } else {
                copyEnd(newTarget, target);
            }
            target = newTarget;

            if (!tokens.test(PIPE) || tokens.test(EOF)) {
                break;
            }

            tokens.next(); // consume '|'
        }
        return target;
    };

    Parser.prototype.matchArguments = function matchArguments() {
        var tokens = this.tokens,
            args = [];
        tokens.expect(LPAREN);
        while (!tokens.test(RPAREN) && !tokens.test(EOF)) {
            if (tokens.test(SYMBOL) && tokens.lat(1) === ASSIGNMENT) {
                var name = tokens.next();
                tokens.next();
                var value = this.matchExpression();
                var arg = new n.NamedArgumentExpression(createNode(n.Identifier, name, name.text), value);
                copyEnd(arg, value);
                args.push(arg);
            } else {
                args.push(this.matchExpression());
            }

            if (!tokens.test(COMMA)) {
                tokens.expect(RPAREN);
                return args;
            }
            tokens.expect(COMMA);
        }
        tokens.expect(RPAREN);
        return args;
    };

    return Parser;
}();

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var TOKENS = Symbol(),
    LENGTH = Symbol();

var TokenStream = function () {
    function TokenStream(lexer, options) {
        classCallCheck(this, TokenStream);

        this.input = lexer;
        this.index = 0;
        var mergedOptions = Object.assign({}, {
            ignoreComments: true,
            ignoreHtmlComments: true,
            ignoreWhitespace: true,
            applyWhitespaceTrimming: true
        }, options);
        this[TOKENS] = getAllTokens(lexer, mergedOptions);
        this[LENGTH] = this[TOKENS].length;

        if (this[TOKENS].length && this[TOKENS][this[TOKENS].length - 1].type === ERROR) {
            var errorToken = this[TOKENS][this[TOKENS].length - 1];
            this.error(errorToken.message, errorToken.pos, errorToken.advice, errorToken.endPos.index - errorToken.pos.index || 1);
        }
    }

    TokenStream.prototype.la = function la(offset) {
        var index = this.index + offset;
        return index < this[LENGTH] ? this[TOKENS][index] : EOF_TOKEN;
    };

    TokenStream.prototype.lat = function lat(offset) {
        return this.la(offset).type;
    };

    TokenStream.prototype.test = function test(type, text) {
        var token = this.la(0);
        return token.type === type && (!text || token.text === text);
    };

    TokenStream.prototype.next = function next() {
        if (this.index === this[LENGTH]) {
            return EOF_TOKEN;
        }
        var token = this[TOKENS][this.index];
        this.index++;
        return token;
    };

    TokenStream.prototype.nextIf = function nextIf(type, text) {
        if (this.test(type, text)) {
            return this.next();
        }
        return false;
    };

    TokenStream.prototype.expect = function expect(type, text) {
        var token = this.la(0);
        if (token.type === type && (!text || token.text === text)) {
            return this.next();
        }
        this.error('Invalid Token', token.pos, 'Expected ' + (ERROR_TABLE[type] || type || text) + ' but found ' + (ERROR_TABLE[token.type] || token.type || token.text) + ' instead.', token.length);
    };

    TokenStream.prototype.error = function error(message, pos, advice) {
        var length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        var metadata = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

        var errorMessage = 'ERROR: ' + message + '\n';
        errorMessage += codeFrame({
            rawLines: this.input.source,
            lineNumber: pos.line,
            colNumber: pos.column,
            length: length,
            tokens: getAllTokens(this.input, {
                ignoreWhitespace: false,
                ignoreComments: false,
                ignoreHtmlComments: false
            })
        });
        if (advice) {
            errorMessage += '\n\n' + advice;
        }
        var result = new Error(errorMessage);
        Object.assign(result, metadata);
        throw result;
    };

    return TokenStream;
}();


function getAllTokens(lexer, options) {
    var token = void 0,
        tokens = [],
        acceptWhitespaceControl = false,
        trimNext = false;
    while ((token = lexer.next()) !== EOF_TOKEN) {
        var shouldTrimNext = trimNext;
        trimNext = false;
        if (acceptWhitespaceControl) {
            switch (token.type) {
                case EXPRESSION_START:
                case TAG_START:
                    if (token.text[token.text.length - 1] === '-') {
                        tokens[tokens.length - 1].text = trimEnd(tokens[tokens.length - 1].text);
                    }
                    break;
                case EXPRESSION_END:
                case TAG_END:
                    if (token.text[0] === '-') {
                        trimNext = true;
                    }
                    break;
                case COMMENT:
                    if (tokens[tokens.length - 1].type === TEXT) {
                        tokens[tokens.length - 1].text = trimEnd(tokens.text);
                    }
                    trimNext = true;
                    break;
            }
        }
        if (shouldTrimNext && (token.type === TEXT || token.type === STRING)) {
            token.text = trimStart(token.text);
        }
        if ((token.type !== COMMENT || !options.ignoreComments) && (token.type !== WHITESPACE || !options.ignoreWhitespace) && (token.type !== HTML_COMMENT || !options.ignoreHtmlComments)) {
            tokens[tokens.length] = token;
        }
        acceptWhitespaceControl = options.applyWhitespaceTrimming;
        if (token.type === ERROR) {
            return tokens;
        }
    }
    return tokens;
}

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var EOF$1 = Symbol();

var CharStream = function () {
    function CharStream(input) {
        classCallCheck(this, CharStream);

        this.input = String(input);
        this.length = this.input.length;
        this.index = 0;
        this.position = { line: 1, column: 0 };
    }

    CharStream.prototype.reset = function reset() {
        this.rewind({ line: 1, column: 0, index: 0 });
    };

    CharStream.prototype.mark = function mark() {
        var _position = this.position,
            line = _position.line,
            column = _position.column,
            index = this.index;

        return { line: line, column: column, index: index };
    };

    CharStream.prototype.rewind = function rewind(marker) {
        this.position.line = marker.line;
        this.position.column = marker.column;
        this.index = marker.index;
    };

    CharStream.prototype.la = function la(offset) {
        var index = this.index + offset;
        return index < this.length ? this.input.charAt(index) : EOF$1;
    };

    CharStream.prototype.lac = function lac(offset) {
        var index = this.index + offset;
        return index < this.length ? this.input.charCodeAt(index) : EOF$1;
    };

    CharStream.prototype.next = function next() {
        if (this.index === this.length) {
            return EOF$1;
        }
        var ch = this.input.charAt(this.index);
        this.index++;
        this.position.column++;
        if (ch === '\n') {
            this.position.line += 1;
            this.position.column = 0;
        }
        return ch;
    };

    CharStream.prototype.match = function match(str) {
        var start = this.mark();
        for (var i = 0, len = str.length; i < len; i++) {
            var ch = this.next();
            if (ch !== str.charAt(i) || ch === EOF$1) {
                this.rewind(start);
                return false;
            }
        }
        return true;
    };

    createClass(CharStream, [{
        key: 'source',
        get: function get$$1() {
            return this.input;
        }
    }]);
    return CharStream;
}();

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var State = {
    TEXT: 'TEXT',
    EXPRESSION: 'EXPRESSION',
    TAG: 'TAG',
    INTERPOLATION: 'INTERPOLATION',
    STRING_SINGLE: 'STRING_SINGLE',
    STRING_DOUBLE: 'STRING_DOUBLE',
    ELEMENT: 'ELEMENT',
    ATTRIBUTE_VALUE: 'ATTRIBUTE_VALUE',
    DECLARATION: 'DECLARATION'
};

var STATE = Symbol(),
    OPERATORS = Symbol(),
    STRING_START$1 = Symbol();

var CHAR_TO_TOKEN = {
    '[': LBRACE,
    ']': RBRACE,
    '(': LPAREN,
    ')': RPAREN,
    '{': LBRACKET,
    '}': RBRACKET,
    ':': COLON,
    '.': DOT,
    '|': PIPE,
    ',': COMMA,
    '?': QUESTION_MARK,
    '=': ASSIGNMENT,
    //'<': TokenTypes.ELEMENT_START,
    //'>': TokenTypes.ELEMENT_END,
    '/': SLASH
};

var Lexer = function () {
    function Lexer(input) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref$preserveSourceLi = _ref.preserveSourceLiterally,
            preserveSourceLiterally = _ref$preserveSourceLi === undefined ? false : _ref$preserveSourceLi;

        classCallCheck(this, Lexer);

        this.input = input;
        this[STATE] = [State.TEXT];
        this[OPERATORS] = [];
        this[STRING_START$1] = null;
        this.options = {
            preserveSourceLiterally: preserveSourceLiterally === true ? true : false
        };
    }

    Lexer.prototype.applyExtension = function applyExtension(ext) {
        if (ext.unaryOperators) {
            this.addOperators.apply(this, ext.unaryOperators.map(function (op) {
                return op.text;
            }));
        }
        if (ext.binaryOperators) {
            this.addOperators.apply(this, ext.binaryOperators.map(function (op) {
                return op.text;
            }));
        }
    };

    Lexer.prototype.reset = function reset() {
        this.input.reset();
        this[STATE] = [State.TEXT];
    };

    Lexer.prototype.addOperators = function addOperators() {
        var _OPERATORS;

        (_OPERATORS = this[OPERATORS]).push.apply(_OPERATORS, arguments);
        this[OPERATORS].sort(function (a, b) {
            return a.length > b.length ? -1 : 1;
        });
    };

    Lexer.prototype.pushState = function pushState(state) {
        this[STATE].push(state);
    };

    Lexer.prototype.popState = function popState() {
        this[STATE].length--;
    };

    Lexer.prototype.createToken = function createToken(type, pos) {
        var input = this.input,
            endPos = input.mark(),
            end = endPos.index;
        return {
            type: type,
            pos: pos,
            endPos: endPos,
            end: end,
            length: end - pos.index,
            source: input.input,
            text: input.input.substr(pos.index, end - pos.index),
            toString: function toString() {
                return this.text;
            }
        };
    };

    Lexer.prototype.next = function next() {
        var input = this.input,
            pos = void 0,
            c = void 0;
        while ((c = input.la(0)) !== EOF$1) {
            pos = input.mark();
            if (this.state !== State.TEXT && this.state !== State.STRING_DOUBLE && this.state !== State.STRING_SINGLE && this.state !== State.ATTRIBUTE_VALUE && isWhitespace(c)) {
                input.next();
                while ((c = input.la(0)) !== EOF$1 && isWhitespace(c)) {
                    input.next();
                }
                return this.createToken(WHITESPACE, pos);
            }
            if (c === '{' && input.la(1) === '#') {
                input.next();
                input.next();
                if (input.la(0) === '-') {
                    input.next();
                }
                while ((c = input.la(0)) !== EOF$1) {
                    if (c === '#' && input.la(1) === '}' || c === '-' && input.la(1) === '#' && input.la(2) === '}') {
                        if (c === '-') {
                            input.next();
                        }
                        input.next();
                        input.next();
                        return this.createToken(COMMENT, pos);
                    }
                    input.next();
                }
            }
            if (this.state === State.TEXT) {
                var entityToken = void 0;
                if (c === '<') {
                    if (input.la(1) === '{' || isAlpha(input.lac(1)) || input.la(1) === '/') {
                        input.next();
                        this.pushState(State.ELEMENT);
                        return this.createToken(ELEMENT_START, pos);
                    } else if (input.la(1) === '!' && input.la(2) === '-' && input.la(3) === '-') {
                        // match HTML comment
                        input.next(); // <
                        input.next(); // !
                        input.next(); // -
                        input.next(); // -
                        while ((c = input.la(0)) !== EOF$1) {
                            if (c === '-' && input.la(1) === '-') {
                                input.next();
                                input.next();
                                if (!(c = input.next()) === '>') {
                                    this.error('Unexpected end for HTML comment', input.mark(), 'Expected comment to end with \'>\' but found \'' + c + '\' instead.');
                                }
                                break;
                            }
                            input.next();
                        }
                        return this.createToken(HTML_COMMENT, pos);
                    } else if (input.la(1) === '!' && (isAlpha(input.lac(2)) || isWhitespace(input.la(2)))) {
                        input.next();
                        input.next();
                        this.pushState(State.DECLARATION);
                        return this.createToken(DECLARATION_START, pos);
                    } else {
                        return this.matchText(pos);
                    }
                } else if (c === '{') {
                    return this.matchExpressionToken(pos);
                } else if (c === '&' && (entityToken = this.matchEntity(pos))) {
                    return entityToken;
                } else {
                    return this.matchText(pos);
                }
            } else if (this.state === State.EXPRESSION) {
                if (c === '}' && input.la(1) === '}' || c === '-' && input.la(1) === '}' && input.la(2) === '}') {
                    if (c === '-') {
                        input.next();
                    }
                    input.next();
                    input.next();
                    this.popState();
                    return this.createToken(EXPRESSION_END, pos);
                }
                return this.matchExpression(pos);
            } else if (this.state === State.TAG) {
                if (c === '%' && input.la(1) === '}' || c === '-' && input.la(1) === '%' && input.la(2) === '}') {
                    if (c === '-') {
                        input.next();
                    }
                    input.next();
                    input.next();
                    this.popState();
                    return this.createToken(TAG_END, pos);
                }
                return this.matchExpression(pos);
            } else if (this.state === State.STRING_SINGLE || this.state === State.STRING_DOUBLE) {
                return this.matchString(pos, true);
            } else if (this.state === State.INTERPOLATION) {
                if (c === '}') {
                    input.next();
                    this.popState(); // pop interpolation
                    return this.createToken(INTERPOLATION_END, pos);
                }
                return this.matchExpression(pos);
            } else if (this.state === State.ELEMENT) {
                switch (c) {
                    case '/':
                        input.next();
                        return this.createToken(SLASH, pos);
                    case '{':
                        return this.matchExpressionToken(pos);
                    case '>':
                        input.next();
                        this.popState();
                        return this.createToken(ELEMENT_END, pos);
                    case '"':
                        input.next();
                        this.pushState(State.ATTRIBUTE_VALUE);
                        return this.createToken(STRING_START, pos);
                    case '=':
                        input.next();
                        return this.createToken(ASSIGNMENT, pos);
                    default:
                        return this.matchSymbol(pos);
                }
            } else if (this.state === State.ATTRIBUTE_VALUE) {
                if (c === '"') {
                    input.next();
                    this.popState();
                    return this.createToken(STRING_END, pos);
                } else {
                    return this.matchAttributeValue(pos);
                }
            } else if (this.state === State.DECLARATION) {
                switch (c) {
                    case '>':
                        input.next();
                        this.popState();
                        return this.createToken(ELEMENT_END, pos);
                    case '"':
                        input.next();
                        this.pushState(State.STRING_DOUBLE);
                        return this.createToken(STRING_START, pos);
                    case '{':
                        return this.matchExpressionToken(pos);
                    default:
                        return this.matchSymbol(pos);
                }
            } else {
                return this.error('Invalid state ' + this.state, pos);
            }
        }
        return EOF_TOKEN;
    };

    Lexer.prototype.matchExpressionToken = function matchExpressionToken(pos) {
        var input = this.input;
        switch (input.la(1)) {
            case '{':
                input.next();
                input.next();
                this.pushState(State.EXPRESSION);
                if (input.la(0) === '-') {
                    input.next();
                }
                return this.createToken(EXPRESSION_START, pos);
            case '%':
                input.next();
                input.next();
                this.pushState(State.TAG);
                if (input.la(0) === '-') {
                    input.next();
                }
                return this.createToken(TAG_START, pos);
            case '#':
                input.next();
                input.next();
                if (input.la(0) === '-') {
                    input.next();
                }
                return this.matchComment(pos);
            default:
                return this.matchText(pos);
        }
    };

    Lexer.prototype.matchExpression = function matchExpression(pos) {
        var input = this.input,
            c = input.la(0);
        switch (c) {
            case "'":
                this.pushState(State.STRING_SINGLE);
                input.next();
                return this.createToken(STRING_START, pos);
            case '"':
                this.pushState(State.STRING_DOUBLE);
                input.next();
                return this.createToken(STRING_START, pos);
            default:
                {
                    if (isDigit(input.lac(0))) {
                        input.next();
                        return this.matchNumber(pos);
                    }
                    if (c === 't' && input.match('true') || c === 'T' && input.match('TRUE')) {
                        return this.createToken(TRUE, pos);
                    }
                    if (c === 'f' && input.match('false') || c === 'F' && input.match('FALSE')) {
                        return this.createToken(FALSE, pos);
                    }
                    if (c === 'n' && (input.match('null') || input.match('none')) || c === 'N' && (input.match('NULL') || input.match('NONE'))) {
                        return this.createToken(NULL, pos);
                    }

                    var _findLongestMatchingO = this.findLongestMatchingOperator(),
                        longestMatchingOperator = _findLongestMatchingO.longestMatchingOperator,
                        longestMatchEndPos = _findLongestMatchingO.longestMatchEndPos;

                    var cc = input.lac(0);
                    if (cc === 95 /* _ */ || isAlpha(cc) || isDigit(cc)) {
                        // okay... this could be either a symbol or an operator
                        input.next();
                        var sym = this.matchSymbol(pos);
                        if (sym.text.length <= longestMatchingOperator.length) {
                            // the operator was longer so let's use that
                            input.rewind(longestMatchEndPos);
                            return this.createToken(OPERATOR, pos);
                        }
                        // found a symbol
                        return sym;
                    } else if (longestMatchingOperator) {
                        input.rewind(longestMatchEndPos);
                        return this.createToken(OPERATOR, pos);
                    } else if (CHAR_TO_TOKEN.hasOwnProperty(c)) {
                        input.next();
                        return this.createToken(CHAR_TO_TOKEN[c], pos);
                    } else if (c === '\xa0') {
                        return this.error('Unsupported token: Non-breaking space', pos);
                    } else {
                        return this.error('Unknown token ' + c, pos);
                    }
                }
        }
    };

    Lexer.prototype.findLongestMatchingOperator = function findLongestMatchingOperator() {
        var input = this.input,
            start = input.mark();
        var longestMatchingOperator = '',
            longestMatchEndPos = null;
        for (var i = 0, ops = this[OPERATORS], len = ops.length; i < len; i++) {
            var op = ops[i];
            if (op.length > longestMatchingOperator.length && input.match(op)) {
                var cc = input.lac(0);

                // prevent mixing up operators with symbols (e.g. matching
                // 'not in' in 'not invalid').
                if (op.indexOf(' ') === -1 || !(isAlpha(cc) || isDigit(cc))) {
                    longestMatchingOperator = op;
                    longestMatchEndPos = input.mark();
                }

                input.rewind(start);
            }
        }
        input.rewind(start);
        return { longestMatchingOperator: longestMatchingOperator, longestMatchEndPos: longestMatchEndPos };
    };

    Lexer.prototype.error = function error(message, pos) {
        var advice = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

        var errorToken = this.createToken(ERROR, pos);
        errorToken.message = message;
        errorToken.advice = advice;
        return errorToken;
    };

    Lexer.prototype.matchEntity = function matchEntity(pos) {
        var input = this.input;
        input.next(); // &
        if (input.la(0) === '#') {
            input.next(); // #
            if (input.la(0) === 'x') {
                // hexadecimal numeric character reference
                input.next(); // x
                var c = input.la(0);
                while ('a' <= c && c <= 'f' || 'A' <= c && c <= 'F' || isDigit(input.lac(0))) {
                    input.next();
                    c = input.la(0);
                }
                if (input.la(0) === ';') {
                    input.next();
                } else {
                    input.rewind(pos);
                    return null;
                }
            } else if (isDigit(input.lac(0))) {
                // decimal numeric character reference
                // consume decimal numbers
                do {
                    input.next();
                } while (isDigit(input.lac(0)));
                // check for final ";"
                if (input.la(0) === ';') {
                    input.next();
                } else {
                    input.rewind(pos);
                    return null;
                }
            } else {
                input.rewind(pos);
                return null;
            }
        } else {
            // match named character reference
            while (isAlpha(input.lac(0))) {
                input.next();
            }
            if (input.la(0) === ';') {
                input.next();
            } else {
                input.rewind(pos);
                return null;
            }
        }
        return this.createToken(ENTITY, pos);
    };

    Lexer.prototype.matchSymbol = function matchSymbol(pos) {
        var input = this.input,
            inElement = this.state === State.ELEMENT,
            c = void 0;
        while ((c = input.lac(0)) && (c === 95 || isAlpha(c) || isDigit(c) || inElement && (c === 45 || c === 58))) {
            input.next();
        }
        var end = input.mark();
        if (pos.index === end.index) {
            return this.error('Expected an Identifier', pos, inElement ? 'Expected a valid attribute name, but instead found "' + input.la(0) + '", which is not part of a valid attribute name.' : 'Expected letter, digit or underscore but found ' + input.la(0) + ' instead.');
        }
        return this.createToken(SYMBOL, pos);
    };

    Lexer.prototype.matchString = function matchString(pos) {
        var allowInterpolation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        var input = this.input,
            start = this.state === State.STRING_SINGLE ? "'" : '"';
        var c = void 0;
        // string starts with an interpolation
        if (allowInterpolation && input.la(0) === '#' && input.la(1) === '{') {
            this.pushState(State.INTERPOLATION);
            input.next();
            input.next();
            return this.createToken(INTERPOLATION_START, pos);
        }
        if (input.la(0) === start) {
            input.next();
            this.popState();
            return this.createToken(STRING_END, pos);
        }
        while ((c = input.la(0)) !== start && c !== EOF$1) {
            if (c === '\\' && input.la(1) === start) {
                // escape sequence for string start
                input.next();
                input.next();
            } else if (allowInterpolation && c === '#' && input.la(1) === '{') {
                // found interpolation start, string part matched
                // next iteration will match the interpolation
                break;
            } else {
                input.next();
            }
        }
        var result = this.createToken(STRING, pos);
        // Replace double backslash before escaped quotes
        if (!this.options.preserveSourceLiterally) {
            result.text = result.text.replace(new RegExp('(?:\\\\)(' + start + ')', 'g'), '$1');
        }
        return result;
    };

    Lexer.prototype.matchAttributeValue = function matchAttributeValue(pos) {
        var input = this.input,
            start = this.state === State.STRING_SINGLE ? "'" : '"',
            c = void 0;
        if (input.la(0) === '{') {
            return this.matchExpressionToken(pos);
        }
        while ((c = input.la(0)) !== start && c !== EOF$1) {
            if (c === '\\' && input.la(1) === start) {
                input.next();
                input.next();
            } else if (c === '{') {
                // interpolation start
                break;
            } else if (c === start) {
                break;
            } else {
                input.next();
            }
        }
        var result = this.createToken(STRING, pos);
        // Replace double backslash before escaped quotes
        if (!this.options.preserveSourceLiterally) {
            result.text = result.text.replace(new RegExp('(?:\\\\)(' + start + ')', 'g'), '$1');
        }
        return result;
    };

    Lexer.prototype.matchNumber = function matchNumber(pos) {
        var input = this.input,
            c = void 0;
        while ((c = input.lac(0)) !== EOF$1) {
            if (!isDigit(c)) {
                break;
            }
            input.next();
        }
        if (input.la(0) === '.' && isDigit(input.lac(1))) {
            input.next();
            while ((c = input.lac(0)) !== EOF$1) {
                if (!isDigit(c)) {
                    break;
                }
                input.next();
            }
        }
        return this.createToken(NUMBER, pos);
    };

    Lexer.prototype.matchText = function matchText(pos) {
        var input = this.input,
            c = void 0;
        while ((c = input.la(0)) && c !== EOF$1) {
            if (c === '{') {
                var c2 = input.la(1);
                if (c2 === '{' || c2 === '#' || c2 === '%') {
                    break;
                }
            } else if (c === '<') {
                var nextChar = input.la(1);
                if (nextChar === '/' || // closing tag
                nextChar === '!' || // HTML comment
                isAlpha(input.lac(1)) // opening tag
                ) {
                        break;
                    } else if (input.la(1) === '{') {
                    var _c = input.la(1);
                    if (_c === '{' || _c === '#' || _c === '%') {
                        break;
                    }
                }
            }
            input.next();
        }
        return this.createToken(TEXT, pos);
    };

    Lexer.prototype.matchComment = function matchComment(pos) {
        var input = this.input,
            c = void 0;
        while ((c = input.next()) !== EOF$1) {
            if (c === '#' && input.la(0) === '}') {
                input.next(); // consume '}'
                break;
            }
        }
        return this.createToken(COMMENT, pos);
    };

    createClass(Lexer, [{
        key: 'source',
        get: function get$$1() {
            return this.input.source;
        }
    }, {
        key: 'state',
        get: function get$$1() {
            return this[STATE][this[STATE].length - 1];
        }
    }]);
    return Lexer;
}();


function isWhitespace(c) {
    return c === '\n' || c === ' ' || c === '\t';
}

function isAlpha(c) {
    return 65 <= c && c <= 90 || 97 <= c && c <= 122;
}

function isDigit(c) {
    return 48 <= c && c <= 57;
}

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function parse(code, options) {
    for (var _len = arguments.length, extensions = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        extensions[_key - 2] = arguments[_key];
    }

    return createExtendedParser.apply(undefined, [code, options].concat(extensions)).parse();
}

function createExtendedParser(code, options) {
    var passedOptions = options;

    for (var _len2 = arguments.length, extensions = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        extensions[_key2 - 2] = arguments[_key2];
    }

    var passedExtensions = extensions;
    if (isMelodyExtension(options)) {
        // Variant without options parameter: createExtendedParser(code, ...extensions)
        passedOptions = undefined;
        passedExtensions.unshift(options);
    }
    var lexer = createExtendedLexer.apply(undefined, [code, options].concat(passedExtensions));
    var parser = new Parser(new TokenStream(lexer, passedOptions), passedOptions);
    for (var _iterator = passedExtensions, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
        } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
        }

        var ext = _ref;

        parser.applyExtension(ext);
    }
    return parser;
}

function createExtendedLexer(code, options) {
    var passedOptions = options;

    for (var _len3 = arguments.length, extensions = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        extensions[_key3 - 2] = arguments[_key3];
    }

    var passedExtensions = extensions;
    if (isMelodyExtension(options)) {
        // Variant without options parameter: createExtendedLexer(code, ...extensions)
        passedOptions = undefined;
        passedExtensions.unshift(options);
    }
    var lexer = new Lexer(new CharStream(code), passedOptions);
    for (var _iterator2 = passedExtensions, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref2 = _iterator2[_i2++];
        } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref2 = _i2.value;
        }

        var ext = _ref2;

        lexer.applyExtension(ext);
    }
    return lexer;
}

exports.Parser = Parser;
exports.TokenStream = TokenStream;
exports.Lexer = Lexer;
exports.EOF = EOF$1;
exports.CharStream = CharStream;
exports.LEFT = LEFT;
exports.RIGHT = RIGHT;
exports.parse = parse;
exports.createExtendedLexer = createExtendedLexer;
exports.createExtendedParser = createExtendedParser;
exports.setStartFromToken = setStartFromToken;
exports.setEndFromToken = setEndFromToken;
exports.copyStart = copyStart;
exports.copyEnd = copyEnd;
exports.copyLoc = copyLoc;
exports.getNodeSource = getNodeSource;
exports.createNode = createNode;
exports.hasTagStartTokenTrimLeft = hasTagStartTokenTrimLeft;
exports.hasTagEndTokenTrimRight = hasTagEndTokenTrimRight;
exports.Types = TokenTypes;
