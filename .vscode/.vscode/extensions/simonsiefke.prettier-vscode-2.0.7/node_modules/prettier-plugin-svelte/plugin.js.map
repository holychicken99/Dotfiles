{"version":3,"file":"plugin.js","sources":["src/print/helpers.ts","src/lib/extractAttributes.ts","src/lib/getText.ts","src/options.ts","src/lib/snipTagContent.ts","src/print/index.ts","src/embed.ts","src/index.ts"],"sourcesContent":["import { Node, ScriptNode, InstanceScriptNode, ModuleScriptNode } from './nodes';\n\nexport interface ASTNode {\n    html: Node;\n    css?: Node & {\n        attributes: Node[];\n        children: Node[];\n        content: Node & {\n            styles: string;\n        };\n    };\n    js?: ScriptNode;\n    instance?: ScriptNode;\n    module?: ScriptNode;\n}\n\nexport function isASTNode(n: any): n is ASTNode {\n    return 'html' in n && 'tokens' in n;\n}\n","import { AttributeNode, TextNode } from '../print/nodes';\n\nexport function extractAttributes(html: string): AttributeNode[] {\n    const extractAttributesRegex = /<[a-z]+\\s*(.*?)>/i;\n    const attributeRegex = /([^\\s=]+)(?:=(\"|')(.*?)\\2)?/gi;\n\n    const [, attributesString] = html.match(extractAttributesRegex)!;\n\n    const attrs: AttributeNode[] = [];\n\n    let match: RegExpMatchArray | null;\n    while ((match = attributeRegex.exec(attributesString))) {\n        const [all, name, quotes, value] = match;\n        const attrStart = match.index!;\n\n        let valueNode: AttributeNode['value'];\n        if (!value) {\n            valueNode = true;\n        } else {\n            let valueStart = attrStart + name.length;\n            if (quotes) {\n                valueStart += 2;\n            }\n\n            valueNode = [\n                {\n                    type: 'Text',\n                    data: value,\n                    start: valueStart,\n                    end: valueStart + value.length,\n                } as TextNode,\n            ];\n        }\n\n        attrs.push({\n            type: 'Attribute',\n            name,\n            value: valueNode,\n            start: attrStart,\n            end: attrStart + all.length,\n        });\n    }\n\n    return attrs;\n}\n","import { ParserOptions } from 'prettier';\nimport { Node } from '../print/nodes';\n\nexport function getText(node: Node, options: ParserOptions) {\n    return options.originalText.slice(options.locStart(node), options.locEnd(node));\n}\n","import { SupportOption } from 'prettier';\n\ndeclare module 'prettier' {\n    interface RequiredOptions extends PluginOptions {}\n}\n\nexport interface PluginOptions {\n    svelteSortOrder: SortOrder;\n    svelteStrictMode: boolean;\n    svelteBracketNewLine: boolean;\n    svelteAllowShorthand: boolean;\n}\n\nexport const options: Record<keyof PluginOptions, SupportOption> = {\n    svelteSortOrder: {\n        type: 'choice',\n        default: 'scripts-styles-markup',\n        description: 'Sort order for scripts, styles, and markup',\n        choices: [\n            { value: 'scripts-styles-markup' },\n            { value: 'scripts-markup-styles' },\n            { value: 'markup-styles-scripts' },\n            { value: 'markup-scripts-styles' },\n            { value: 'styles-markup-scripts' },\n            { value: 'styles-scripts-markup' },\n        ],\n    },\n    svelteStrictMode: {\n        type: 'boolean',\n        default: false,\n        description: 'More strict HTML syntax: self-closed tags, quotes in attributes',\n    },\n    svelteBracketNewLine: {\n        type: 'boolean',\n        default: false,\n        description: 'Put the `>` of a multiline element on a new line',\n    },\n    svelteAllowShorthand: {\n        type: 'boolean',\n        default: true,\n        description: 'Option to enable/disable component attribute shorthand if attribute name and expressions are same',\n    },\n};\n\nexport type SortOrder =\n    | 'scripts-styles-markup'\n    | 'scripts-markup-styles'\n    | 'markup-styles-scripts'\n    | 'markup-scripts-styles'\n    | 'styles-markup-scripts'\n    | 'styles-scripts-markup';\n\nexport type SortOrderPart = 'scripts' | 'markup' | 'styles';\n\nconst sortOrderSeparator = '-';\n\nexport function parseSortOrder(sortOrder: SortOrder): SortOrderPart[] {\n    return sortOrder.split(sortOrderSeparator) as SortOrderPart[];\n}\n","export function snipTagContent(tagName: string, source: string, placeholder = ''): string {\n    const regex = new RegExp(`[\\s\\n]*<${tagName}([^]*?)>([^]*?)<\\/${tagName}>[\\s\\n]*`, 'gi');\n    return source.replace(regex, (_, attributes, content) => {\n        const encodedContent = Buffer.from(content).toString('base64');\n        return `<${tagName}${attributes} ✂prettier:content✂=\"${encodedContent}\">${placeholder}</${tagName}>`;\n    });\n}\n\nexport function hasSnippedContent(text: string) {\n    return text.includes('✂prettier:content✂');\n}\n\nexport function unsnipContent(text: string): string {\n    const regex = /(<\\w+.*?)\\s*✂prettier:content✂=\"(.*?)\">.*?(?=<\\/)/gi\n    return text.replace(regex, (_, start, encodedContent) => {\n        const content = Buffer.from(encodedContent, 'base64').toString('utf8');\n        return `${start}>${content}`;\n    });\n    return text;\n}\n","import { FastPath, Doc, doc, ParserOptions } from 'prettier';\nimport { Node, IdentifierNode, MustacheTagNode, IfBlockNode, EachBlockNode } from './nodes';\nimport { isASTNode } from './helpers';\nimport { extractAttributes } from '../lib/extractAttributes';\nimport { getText } from '../lib/getText';\nimport { parseSortOrder, SortOrderPart } from '../options';\nimport { hasSnippedContent, unsnipContent } from '../lib/snipTagContent';\nconst {\n    concat,\n    join,\n    line,\n    group,\n    indent,\n    dedent,\n    softline,\n    hardline,\n    fill,\n    breakParent,\n    literalline,\n} = doc.builders;\n\nexport type PrintFn = (path: FastPath) => Doc;\n\ndeclare module 'prettier' {\n    export namespace doc {\n        namespace builders {\n            interface Line {\n                keepIfLonely?: boolean;\n            }\n        }\n    }\n}\n\n// @see http://xahlee.info/js/html5_non-closing_tag.html\nconst SELF_CLOSING_TAGS = [\n    'area',\n    'base',\n    'br',\n    'col',\n    'embed',\n    'hr',\n    'img',\n    'input',\n    'link',\n    'meta',\n    'param',\n    'source',\n    'track',\n    'wbr',\n];\n\nlet ignoreNext = false;\n\nexport function print(path: FastPath, options: ParserOptions, print: PrintFn): Doc {\n    const n = path.getValue();\n    if (!n) {\n        return '';\n    }\n\n    if (isASTNode(n)) {\n        const parts: doc.builders.Doc[] = [];\n        const addParts: Record<SortOrderPart, () => void> = {\n            scripts() {\n                if (n.module) {\n                    n.module.type = 'Script';\n                    n.module.attributes = extractAttributes(getText(n.module, options));\n                    parts.push(path.call(print, 'module'));\n                }\n                if (n.instance) {\n                    n.instance.type = 'Script';\n                    n.instance.attributes = extractAttributes(getText(n.instance, options));\n                    parts.push(path.call(print, 'instance'));\n                }\n            },\n            styles() {\n                if (n.css) {\n                    n.css.type = 'Style';\n                    n.css.content.type = 'StyleProgram';\n                    parts.push(path.call(print, 'css'));\n                }\n            },\n            markup() {\n                const htmlDoc = path.call(print, 'html');\n                if (htmlDoc) {\n                    parts.push(htmlDoc);\n                }\n            },\n        };\n        parseSortOrder(options.svelteSortOrder).forEach(p => addParts[p]());\n        return group(join(hardline, parts));\n    }\n\n    const [open, close] = options.svelteStrictMode ? ['\"{', '}\"'] : ['{', '}'];\n    const node = n as Node;\n\n    if (ignoreNext && (node.type !== 'Text' || !isEmptyNode(node))) {\n        ignoreNext = false\n        return concat(\n            options.originalText.slice(\n                options.locStart(node),\n                options.locEnd(node)\n            )\n            .split('\\n')\n            .flatMap((o, i) => i == 0 ? o : [literalline, o])\n        );\n    }\n\n    switch (node.type) {\n        case 'Fragment':\n            const children = node.children;\n\n            if (children.length === 0 || children.every(isEmptyNode)) {\n                return '';\n            }\n\n            return concat([printChildren(path, print, false), hardline]);\n        case 'Text':\n            if (isEmptyNode(node)) {\n                return {\n                    /**\n                     * Empty (whitespace-only) text nodes are collapsed into a single `line`,\n                     * which will be rendered as a single space if this node's group fits on a\n                     * single line. This follows how vanilla HTML is handled both by browsers and\n                     * by Prettier core.\n                     */\n                    ...line,\n\n                    /**\n                     * A text node is considered lonely if it is in a group without other inline\n                     * elements, such as the line breaks between otherwise consecutive HTML tags.\n                     * Text nodes that are both empty and lonely are discarded unless they have at\n                     * least one empty line (i.e. at least two linebreak sequences). This is to\n                     * allow for flexible grouping of HTML tags in a particular indentation level,\n                     * and is similar to how vanilla HTML is handled in Prettier core.\n                     */\n                    keepIfLonely: /\\n\\r?\\s*\\n\\r?/.test(node.raw || node.data),\n                };\n            }\n\n            /**\n             * For non-empty text nodes each sequence of non-whitespace characters (effectively,\n             * each \"word\") is joined by a single `line`, which will be rendered as a single space\n             * until this node's current line is out of room, at which `fill` will break at the\n             * most convienient instance of `line`.\n             */\n            return fill(join(line, (node.raw || node.data).split(/[\\t\\n\\f\\r ]+/)).parts);\n        case 'Element':\n        case 'InlineComponent':\n        case 'Slot':\n        case 'Window':\n        case 'Head':\n        case 'Title': {\n            const isEmpty = node.children.every(child => isEmptyNode(child));\n\n            const isSelfClosingTag =\n                isEmpty &&\n                (!options.svelteStrictMode ||\n                    node.type !== 'Element' ||\n                    SELF_CLOSING_TAGS.indexOf(node.name) !== -1);\n\n            return group(\n                concat([\n                    '<',\n                    node.name,\n\n                    indent(\n                        group(\n                            concat([\n                                node.type === 'InlineComponent' && node.expression\n                                    ? concat([\n                                        line,\n                                        'this=',\n                                        open,\n                                        printJS(path, print, 'expression'),\n                                        close,\n                                    ])\n                                    : '',\n                                ...path.map(childPath => childPath.call(print), 'attributes'),\n                                options.svelteBracketNewLine\n                                    ? dedent(isSelfClosingTag ? line : softline)\n                                    : '',\n                            ]),\n                        ),\n                    ),\n\n                    isSelfClosingTag ? `${options.svelteBracketNewLine ? '' : ' '}/>` : '>',\n\n                    isEmpty ? '' : indent(printChildren(path, print)),\n\n                    isSelfClosingTag ? '' : concat(['</', node.name, '>']),\n                ]),\n            );\n        }\n        case 'Options':\n        case 'Body':\n            return group(\n                concat([\n                    '<',\n                    node.name,\n\n                    indent(\n                        group(concat(path.map(childPath => childPath.call(print), 'attributes'))),\n                    ),\n\n                    ' />',\n                ]),\n            );\n        case 'Identifier':\n\t\t\t\t\treturn node.name;\n\t\t\t\tcase 'AttributeShorthand': {\n\t\t\t\t\treturn node.expression.name;\n\t\t\t\t}\n        case 'Attribute': {\n            const hasLoneMustacheTag =\n                node.value !== true &&\n                node.value.length === 1 &&\n                node.value[0].type === 'MustacheTag';\n            let isAttributeShorthand =\n                node.value !== true &&\n                node.value.length === 1 &&\n                node.value[0].type === 'AttributeShorthand';\n\n            // Convert a={a} into {a}\n            if (hasLoneMustacheTag) {\n                const expression = (node.value as [MustacheTagNode])[0].expression;\n                isAttributeShorthand =\n\t\t\t\t\t\t\t\t\texpression.type === 'Identifier' && expression.name === node.name;\n            }\n\n            if (isAttributeShorthand && options.svelteAllowShorthand) {\n                return concat([line, '{', node.name, '}']);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst def: Doc[] = [line, node.name];\n\t\t\t\t\t\t\tif (node.value !== true) {\n\t\t\t\t\t\t\t\t\tdef.push('=');\n\t\t\t\t\t\t\t\t\tconst quotes = !hasLoneMustacheTag || options.svelteStrictMode;\n\n\t\t\t\t\t\t\t\t\tquotes && def.push('\"');\n\t\t\t\t\t\t\t\t\tdef.push(...path.map(childPath => childPath.call(print), 'value'));\n\t\t\t\t\t\t\t\t\tquotes && def.push('\"');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn concat(def);\n\t\t\t\t\t\t}\n        }\n        case 'MustacheTag':\n            return concat(['{', printJS(path, print, 'expression'), '}']);\n        case 'IfBlock': {\n            const def: Doc[] = [\n                '{#if ',\n                printJS(path, print, 'expression'),\n                '}',\n                indent(printChildren(path, print)),\n            ];\n\n            if (node.else) {\n                def.push(path.call(print, 'else'));\n            }\n\n            def.push('{/if}');\n\n            return group(concat(def));\n        }\n        case 'ElseBlock': {\n            // Else if\n            const parent = path.getParentNode() as Node;\n\n            if (\n                node.children.length === 1 &&\n                node.children[0].type === 'IfBlock' &&\n                parent.type !== 'EachBlock'\n            ) {\n                const ifNode = node.children[0] as IfBlockNode;\n                const def: Doc[] = [\n                    '{:else if ',\n                    path.map(ifPath => printJS(path, print, 'expression'), 'children')[0],\n                    '}',\n                    indent(path.map(ifPath => printChildren(ifPath, print), 'children')[0]),\n                ];\n\n                if (ifNode.else) {\n                    def.push(path.map(ifPath => ifPath.call(print, 'else'), 'children')[0]);\n                }\n                return group(concat(def));\n            }\n\n            return group(concat(['{:else}', indent(printChildren(path, print))]));\n        }\n        case 'EachBlock': {\n            const def: Doc[] = [\n                '{#each ',\n                printJS(path, print, 'expression'),\n                ' as ',\n                printJS(path, print, 'context'),\n            ];\n\n            if (node.index) {\n                def.push(', ', node.index);\n            }\n\n            if (node.key) {\n                def.push(' (', printJS(path, print, 'key'), ')');\n            }\n\n            def.push('}', indent(printChildren(path, print)));\n\n            if (node.else) {\n                def.push(path.call(print, 'else'));\n            }\n\n            def.push('{/each}');\n\n            return group(concat(def));\n        }\n        case 'AwaitBlock': {\n            const hasPendingBlock = node.pending.children.some((n) => !isEmptyNode(n));\n            const hasThenBlock = node.then.children.some((n) => !isEmptyNode(n));\n            const hasCatchBlock = node.catch.children.some((n) => !isEmptyNode(n));\n\n            let block = [];\n\n            if (!hasPendingBlock && hasThenBlock) {\n                block.push(\n                    group(\n                        concat([\n                            '{#await ',\n                            printJS(path, print, 'expression'),\n                            ' then',\n                            expandNode(node.value),\n                            '}',\n                        ]),\n                    ),\n                    indent(path.call(print, 'then')),\n                );\n            } else {\n                block.push(group(concat(['{#await ', printJS(path, print, 'expression'), '}'])));\n\n                if (hasPendingBlock) {\n                    block.push(indent(path.call(print, 'pending')));\n                }\n\n                if (hasThenBlock) {\n                    block.push(\n                        group(concat(['{:then', expandNode(node.value), '}'])),\n                        indent(path.call(print, 'then')),\n                    );\n                }\n            }\n\n            if (hasCatchBlock) {\n                block.push(\n                    group(concat(['{:catch', expandNode(node.error), '}'])),\n                    indent(path.call(print, 'catch')),\n                );\n            }\n\n            block.push('{/await}');\n\n            return group(concat(block));\n        }\n        case 'ThenBlock':\n        case 'PendingBlock':\n        case 'CatchBlock':\n            return printChildren(path, print);\n        case 'EventHandler':\n            return concat([\n                line,\n                'on:',\n                node.name,\n                node.modifiers && node.modifiers.length\n                    ? concat(['|', join('|', node.modifiers)])\n                    : '',\n                node.expression\n                    ? concat(['=', open, printJS(path, print, 'expression'), close])\n                    : '',\n            ]);\n        case 'Binding':\n            return concat([\n                line,\n                'bind:',\n                node.name,\n                node.expression.type === 'Identifier' && node.expression.name === node.name\n                    ? ''\n                    : concat(['=', open, printJS(path, print, 'expression'), close]),\n            ]);\n        case 'Class':\n            return concat([\n                line,\n                'class:',\n                node.name,\n                node.expression.type === 'Identifier' && node.expression.name === node.name\n                    ? ''\n                    : concat(['=', open, printJS(path, print, 'expression'), close]),\n            ]);\n        case 'Let':\n            return concat([\n                line,\n                'let:',\n                node.name,\n                // shorthand let directives have `null` expressions\n                !node.expression ||\n                    (node.expression.type === 'Identifier' && node.expression.name === node.name)\n                    ? ''\n                    : concat(['=', open, printJS(path, print, 'expression'), close]),\n            ]);\n        case 'DebugTag':\n            return concat([\n                '{@debug',\n                node.identifiers.length > 0\n                    ? concat([' ', join(', ', path.map(print, 'identifiers'))])\n                    : '',\n                '}',\n            ]);\n        case 'Ref':\n            return concat([line, 'ref:', node.name]);\n        case 'Comment': {\n            let text = node.data;\n            ignoreNext = text.trim() === 'prettier-ignore';\n            if (hasSnippedContent(text)) {\n                text = unsnipContent(text);\n            }\n\n            return group(concat(['<!--', text, '-->']));\n        }\n        case 'Transition':\n            const kind = node.intro && node.outro ? 'transition' : node.intro ? 'in' : 'out';\n            return concat([\n                line,\n                kind,\n                ':',\n                node.name,\n                node.modifiers && node.modifiers.length\n                    ? concat(['|', join('|', node.modifiers)])\n                    : '',\n                node.expression\n                    ? concat(['=', open, printJS(path, print, 'expression'), close])\n                    : '',\n            ]);\n        case 'Action':\n            return concat([\n                line,\n                'use:',\n                node.name,\n                node.expression\n                    ? concat(['=', open, printJS(path, print, 'expression'), close])\n                    : '',\n            ]);\n        case 'Animation':\n            return concat([\n                line,\n                'animate:',\n                node.name,\n                node.expression\n                    ? concat(['=', open, printJS(path, print, 'expression'), close])\n                    : '',\n            ]);\n        case 'RawMustacheTag':\n            return concat(['{@html ', printJS(path, print, 'expression'), '}']);\n        case 'Spread':\n            return concat([line, '{...', printJS(path, print, 'expression'), '}']);\n    }\n\n    console.log(JSON.stringify(node, null, 4));\n    throw new Error('unknown node type: ' + node.type);\n}\n\nfunction isEmptyGroup(group: Doc[]): boolean {\n    if (group.length === 0) {\n        return true;\n    }\n\n    if (group.length > 1) {\n        return false;\n    }\n\n    const lonelyDoc = group[0];\n\n    if (typeof lonelyDoc === 'string' || lonelyDoc.type !== 'line') {\n        return false;\n    }\n\n    return !lonelyDoc.keepIfLonely;\n}\n\n/**\n * Due to how `String.prototype.split` works, `TextNode`s with leading whitespace will be printed\n * to a `Fill` that has two additional parts at the begnning: an empty string (`''`) and a `line`.\n * If such a `Fill` doc is present at the beginning of an inline node group, those additional parts\n * need to be removed to prevent additional whitespace at the beginning of the parent's inner\n * content or after a sibling block node (i.e. HTML tags).\n */\nfunction trimLeft(group: Doc[]): void {\n    if (group.length === 0) {\n        return;\n    }\n\n    const first = group[0];\n    if (typeof first === 'string') {\n        return;\n    }\n\n    if (first.type === 'line') {\n        group.shift();\n        return;\n    }\n\n    if (first.type !== 'fill') {\n        return;\n    }\n\n    // find the index of the first part that isn't an empty string or a line\n    const trimIndex = first.parts.findIndex(part =>\n        typeof part === 'string' ? part !== '' : part.type !== 'line',\n    );\n\n    first.parts.splice(0, trimIndex);\n}\n\n/**\n * Due to how `String.prototype.split` works, `TextNode`s with trailing whitespace will be printed\n * to a `Fill` that has two additional parts at the end: a `line` and an empty string (`''`). If\n * such a `Fill` doc is present at the beginning of an inline node group, those additional parts\n * need to be removed to prevent additional whitespace at the end of the parent's inner content or\n * before a sibling block node (i.e. HTML tags).\n */\nfunction trimRight(group: Doc[]): void {\n    if (group.length === 0) {\n        return;\n    }\n\n    const last = group[group.length - 1];\n    if (typeof last === 'string') {\n        return;\n    }\n\n    if (last.type === 'line') {\n        group.pop();\n        return;\n    }\n\n    if (last.type !== 'fill') {\n        return;\n    }\n\n    last.parts.reverse();\n\n    // find the index of the first part that isn't an empty string or a line\n    const trimIndex = last.parts.findIndex(part =>\n        typeof part === 'string' ? part !== '' : part.type !== 'line',\n    );\n\n    last.parts.splice(0, trimIndex);\n    last.parts.reverse();\n}\n\nfunction printChildren(path: FastPath, print: PrintFn, surroundingLines = true): Doc {\n    const childDocs: Doc[] = [];\n    let currentGroup: Doc[] = [];\n\n    /**\n     * Sequences of inline nodes (currently, `TextNode`s and `MustacheTag`s) are collected into\n     * groups and printed as a single `Fill` doc so that linebreaks as a result of sibling block\n     * nodes (currently, all HTML elements) don't cause those inline sequences to break\n     * prematurely. This is particularly important for whitespace sensitivity, as it is often\n     * desired to have text directly wrapping a mustache tag without additional whitespace.\n     */\n    function flush() {\n        if (!isEmptyGroup(currentGroup)) {\n            trimLeft(currentGroup);\n            trimRight(currentGroup);\n            childDocs.push(fill(currentGroup));\n        }\n        currentGroup = [];\n    }\n\n    path.each(childPath => {\n        const childNode = childPath.getValue() as Node;\n        const childDoc = childPath.call(print);\n\n        if (isInlineNode(childNode)) {\n            currentGroup.push(childDoc);\n        } else {\n            flush();\n            childDocs.push(concat([breakParent, childDoc]));\n        }\n    }, 'children');\n\n    flush();\n\n    return concat([\n        surroundingLines ? softline : '',\n        join(hardline, childDocs),\n        surroundingLines ? dedent(softline) : '',\n    ]);\n}\n\nfunction printJS(path: FastPath, print: PrintFn, name?: string) {\n    if (!name) {\n        path.getValue().isJS = true;\n        return path.call(print);\n    }\n\n    path.getValue()[name].isJS = true;\n    return path.call(print, name);\n}\n\nfunction isInlineNode(node: Node): boolean {\n    return node.type === 'Text' || node.type === 'MustacheTag';\n}\n\nfunction isEmptyNode(node: Node): boolean {\n    return node.type === 'Text' && (node.raw || node.data).trim() === '';\n}\n\nfunction expandNode(node): string {\n    if (node === null) {\n        return '';\n    }\n\n    if (typeof node === 'string') {\n        // pre-v3.20 AST\n        return ' ' + node;\n    }\n\n    switch (node.type) {\n        case 'ArrayPattern':\n            return ' [' + node.elements.map(expandNode).join(',').slice(1) + ']';\n        case 'AssignmentPattern':\n            return expandNode(node.left) + ' =' + expandNode(node.right);\n        case 'Identifier':\n            return ' ' + node.name;\n        case 'Literal':\n            return ' ' + node.raw;\n        case 'ObjectPattern':\n            return ' {' + node.properties.map(expandNode).join(',') + ' }';\n        case 'Property':\n            if (node.value.type === 'ObjectPattern') {\n                return ' ' + node.key.name + ':' + expandNode(node.value);\n            } else {\n                return expandNode(node.value);\n            }\n        case 'RestElement':\n            return ' ...' + node.argument.name;\n    }\n\n    console.log(JSON.stringify(node, null, 4));\n    throw new Error('unknown node type: ' + node.type);\n}\n","import { FastPath, Doc, doc, ParserOptions } from 'prettier';\nimport { PrintFn } from './print';\nimport { Node, AttributeNode, TextNode } from './print/nodes';\nimport { getText } from './lib/getText';\n\nconst {\n    builders: { concat, hardline, group, indent },\n    utils: { removeLines },\n} = doc;\n\nexport function embed(\n    path: FastPath,\n    print: PrintFn,\n    textToDoc: (text: string, options: object) => Doc,\n    options: ParserOptions,\n): Doc | null {\n    const node: Node = path.getNode();\n    if (node.isJS) {\n        return removeLines(\n            textToDoc(getText(node, options), {\n                parser: expressionParser,\n                singleQuote: true,\n            }),\n        );\n    }\n\n    switch (node.type) {\n        case 'Script':\n            return embedTag('script', path, print, textToDoc, node);\n        case 'Style':\n            return embedTag('style', path, print, textToDoc, node);\n        case 'Element': {\n            if (node.name === 'script' || node.name === 'style') {\n                return embedTag(node.name, path, print, textToDoc, node, true)\n            }\n        }\n    }\n\n    return null;\n}\n\nfunction expressionParser(text: string, parsers: any) {\n    const ast = parsers.babel(`(${text})`);\n    return {\n        type: 'File',\n        program: ast.program.body[0].expression,\n    };\n}\n\nfunction skipBlank(docs: Doc[]): number {\n    for (let i = docs.length - 1; i >= 0; i--) {\n        const doc = docs[i];\n        if (typeof doc !== 'string') {\n            if (doc.type === 'break-parent') {\n                continue;\n            }\n        }\n\n        return i;\n    }\n\n    return -1;\n}\n\nfunction nukeLastLine(doc: Doc): Doc {\n    if (typeof doc === 'string') {\n        return doc;\n    }\n\n    switch (doc.type) {\n        case 'concat':\n            const end = skipBlank(doc.parts);\n            if (end > -1) {\n                return concat([\n                    ...doc.parts.slice(0, end),\n                    nukeLastLine(doc.parts[end]),\n                    ...doc.parts.slice(end + 1),\n                ]);\n            }\n            break;\n        case 'line':\n            return '';\n    }\n\n    return doc;\n}\n\nfunction embedTag(\n    tag: string,\n    path: FastPath,\n    print: PrintFn,\n    textToDoc: (text: string, options: object) => Doc,\n    node: Node & { attributes: Node[] },\n    inline: boolean,\n) {\n    const parser = tag === 'script' ? 'typescript' : 'css';\n    const contentAttribute = (node.attributes as AttributeNode[]).find(\n        n => n.name === '✂prettier:content✂',\n    );\n    let content = '';\n    if (\n        contentAttribute &&\n        Array.isArray(contentAttribute.value) &&\n        contentAttribute.value.length > 0\n    ) {\n        const encodedContent = (contentAttribute.value[0] as TextNode).data;\n        content = Buffer.from(encodedContent, 'base64').toString('utf-8');\n    }\n    node.attributes = node.attributes.filter(n => n !== contentAttribute);\n\n    return group(\n        concat([\n            '<',\n            tag,\n            indent(group(concat(path.map(childPath => childPath.call(print), 'attributes')))),\n            '>',\n            indent(concat([hardline, nukeLastLine(textToDoc(content, { parser }))])),\n            hardline,\n            '</',\n            tag,\n            '>',\n            inline ? '' : hardline,\n        ]),\n    );\n}\n","import { SupportLanguage, Parser, Printer } from 'prettier';\nimport { print } from './print';\nimport { embed } from './embed';\nimport { snipTagContent } from './lib/snipTagContent';\n\nfunction locStart(node: any) {\n    return node.start;\n}\n\nfunction locEnd(node: any) {\n    return node.end;\n}\n\nexport const languages: Partial<SupportLanguage>[] = [\n    {\n        name: 'svelte',\n        parsers: ['svelte'],\n        extensions: ['.svelte'],\n    },\n];\n\nexport const parsers: Record<string, Parser> = {\n    svelte: {\n        parse: text => {\n            try {\n                return require(`svelte/compiler`).parse(text);\n            } catch (err) {\n                err.loc = {\n                    start: err.start,\n                    end: err.end,\n                };\n                delete err.start;\n                delete err.end;\n                throw err;\n            }\n        },\n        preprocess: text => {\n            text = snipTagContent('style', text);\n            text = snipTagContent('script', text, '{}');\n            return text.trim();\n        },\n        locStart,\n        locEnd,\n        astFormat: 'svelte-ast',\n    },\n};\n\nexport const printers: Record<string, Printer> = {\n    'svelte-ast': {\n        print,\n        embed,\n    },\n};\n\nexport { options } from './options';\n"],"names":["doc","options","concat","hardline","group","indent"],"mappings":"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"}