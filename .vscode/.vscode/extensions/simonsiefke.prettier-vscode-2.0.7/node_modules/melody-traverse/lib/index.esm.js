import { ALIAS_TO_TYPE, PATH_CACHE_KEY, Node, is } from 'melody-types';

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var EXPLODED = Symbol();

function explode(visitor) {
    if (visitor[EXPLODED]) {
        return visitor;
    }
    visitor[EXPLODED] = true;

    for (var _iterator = Object.getOwnPropertyNames(visitor), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
        } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
        }

        var key = _ref;

        // make sure all members are objects with enter and exit methods
        var fns = visitor[key];
        if (typeof fns === 'function') {
            fns = visitor[key] = { enter: fns };
        }

        // make sure enter and exit are arrays
        if (fns.enter && !Array.isArray(fns.enter)) {
            fns.enter = [fns.enter];
        }
        if (fns.exit && !Array.isArray(fns.exit)) {
            fns.exit = [fns.exit];
        }
    }

    var j = 0;
    var visitorKeys = Object.getOwnPropertyNames(visitor);
    var visitorKeyLength = visitorKeys.length;
    for (; j < visitorKeyLength; j++) {
        var _key = visitorKeys[j];
        // manage aliases
        if (ALIAS_TO_TYPE[_key]) {
            var i = 0;
            for (var types = ALIAS_TO_TYPE[_key], len = types.length; i < len; i++) {
                var type = types[i];
                if (!visitor[type]) {
                    visitor[type] = { enter: [] };
                }
                if (visitor[_key].enter) {
                    var _visitor$type$enter;

                    (_visitor$type$enter = visitor[type].enter).push.apply(_visitor$type$enter, visitor[_key].enter);
                }
                if (visitor[_key].exit) {
                    var _visitor$type$exit;

                    if (!visitor[type].exit) {
                        visitor[type].exit = [];
                    }
                    (_visitor$type$exit = visitor[type].exit).push.apply(_visitor$type$exit, visitor[_key].exit);
                }
            }
            delete visitor[_key];
        }
    }
}

function merge() {
    var rootVisitor = {};

    var i = 0;
    for (var len = arguments.length; i < len; i++) {
        var visitor = arguments.length <= i ? undefined : arguments[i];
        explode(visitor);

        var j = 0;
        var visitorTypes = Object.getOwnPropertyNames(visitor);
        for (var numberOfTypes = visitorTypes.length; j < numberOfTypes; j++) {
            var key = visitorTypes[j];
            var visitorType = visitor[key];

            if (!rootVisitor[key]) {
                rootVisitor[key] = {};
            }

            var nodeVisitor = rootVisitor[key];
            nodeVisitor.enter = [].concat(nodeVisitor.enter || [], visitorType.enter || []);
            nodeVisitor.exit = [].concat(nodeVisitor.exit || [], visitorType.exit || []);
        }
    }

    return rootVisitor;
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var TraversalContext = function () {
    function TraversalContext(scope, visitor, state, parentPath) {
        classCallCheck(this, TraversalContext);

        this.parentPath = parentPath;
        this.scope = scope;
        this.state = state;
        this.visitor = visitor;

        this.queue = null;
        this.priorityQueue = null;
    }

    TraversalContext.prototype.create = function create(parent, container, key, listKey) {
        return Path.get({
            parentPath: this.parentPath,
            parent: parent,
            container: container,
            key: key,
            listKey: listKey
        });
    };

    TraversalContext.prototype.shouldVisit = function shouldVisit(node) {
        var visitor = this.visitor;

        if (visitor[node.type]) {
            return true;
        }

        var keys = node.visitorKeys;
        // this node doesn't have any children
        if (!keys || !keys.length) {
            return false;
        }

        var i = void 0,
            len = void 0;
        for (i = 0, len = keys.length; i < len; i++) {
            // check if some of its visitor keys have a value,
            // if so, we need to visit it
            if (node[keys[i]]) {
                return true;
            }
        }

        return false;
    };

    TraversalContext.prototype.visit = function visit(node, key) {
        var nodes = node[key];
        if (!nodes) {
            return false;
        }

        if (Array.isArray(nodes)) {
            return this.visitMultiple(nodes, node, key);
        } else {
            return this.visitSingle(node, key);
        }
    };

    TraversalContext.prototype.visitSingle = function visitSingle(node, key) {
        if (this.shouldVisit(node[key])) {
            return this.visitQueue([this.create(node, node, key)]);
        } else {
            return false;
        }
    };

    TraversalContext.prototype.visitMultiple = function visitMultiple(container, parent, listKey) {
        if (!container.length) {
            return false;
        }

        var queue = [];

        for (var i = 0, len = container.length; i < len; i++) {
            var node = container[i];
            if (node && this.shouldVisit(node)) {
                queue.push(this.create(parent, container, i, listKey));
            }
        }

        return this.visitQueue(queue);
    };

    TraversalContext.prototype.visitQueue = function visitQueue(queue) {
        this.queue = queue;
        this.priorityQueue = [];

        var visited = [],
            stop = false;

        for (var _iterator = queue, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            var path = _ref;

            path.resync();
            path.pushContext(this);

            if (visited.indexOf(path.node) >= 0) {
                continue;
            }
            visited.push(path.node);

            if (path.visit()) {
                stop = true;
                break;
            }

            if (this.priorityQueue.length) {
                stop = this.visitQueue(this.priorityQueue);
                this.priorityQueue = [];
                this.queue = queue;
                if (stop) {
                    break;
                }
            }
        }

        for (var _iterator2 = queue, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray2) {
                if (_i2 >= _iterator2.length) break;
                _ref2 = _iterator2[_i2++];
            } else {
                _i2 = _iterator2.next();
                if (_i2.done) break;
                _ref2 = _i2.value;
            }

            var _path = _ref2;

            _path.popContext();
        }

        this.queue = null;

        return stop;
    };

    TraversalContext.prototype.maybeQueue = function maybeQueue(path, notPriority) {
        if (this.queue) {
            if (notPriority) {
                this.queue.push(path);
            } else {
                this.priorityQueue.push(path);
            }
        }
    };

    return TraversalContext;
}();

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function traverse(parentNode, visitor, scope) {
    var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var parentPath = arguments[4];

    if (!parentNode) {
        return;
    }

    explode(visitor);
    visit(parentNode, visitor, scope, state, parentPath);
}

function visit(node, visitor, scope, state, parentPath) {
    var keys = node.visitorKeys;
    if (!keys || !keys.length) {
        return;
    }

    var context = new TraversalContext(scope, visitor, state, parentPath);
    for (var i = 0, len = keys.length; i < len; i++) {
        var key = keys[i];
        if (context.visit(node, key)) {
            return;
        }
    }
}

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Binding = function () {
    function Binding(identifier, scope, path) {
        var kind = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'global';
        classCallCheck(this, Binding);

        this.identifier = identifier;
        this.scope = scope;
        this.path = path;
        this.kind = kind;

        this.referenced = false;
        this.references = 0;
        this.referencePaths = [];
        this.definitionPaths = [];
        this.shadowedBinding = null;
        this.contextual = false;

        this.data = Object.create(null);
    }

    Binding.prototype.getData = function getData(key) {
        return this.data[key];
    };

    Binding.prototype.setData = function setData(key, value) {
        this.data[key] = value;
    };

    Binding.prototype.reference = function reference(path) {
        this.referenced = true;
        this.references++;
        this.referencePaths.push(path);
    };

    // dereference(path) {
    //   if (path) {
    //     this.referencePaths.splice(this.referencePaths.indexOf(path), 1);
    //   }
    //   this.references--;
    //   this.referenced = !!this.references;
    // }

    Binding.prototype.getRootDefinition = function getRootDefinition() {
        if (this.shadowedBinding) {
            return this.shadowedBinding.getRootDefinition();
        }
        return this;
    };

    return Binding;
}();

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var CACHE_KEY = Symbol();
var uid = 0;

var Scope = function () {
    function Scope(path, parentScope) {
        classCallCheck(this, Scope);

        this.uid = uid++;
        this.parent = parentScope;

        this.parentBlock = path.parent;
        this.block = path.node;
        this.path = path;

        this.references = Object.create(null);
        this.bindings = Object.create(null);
        this.globals = Object.create(null);
        this.uids = Object.create(null);
        this.escapesContext = false;
        this._contextName = null;
        this.mutated = false;
        //this.contextName = parentScope && parentScope.contextName || '_context';
    }

    Scope.get = function get$$1(path, parentScope) {
        if (parentScope && parentScope.block == path.node) {
            return parentScope;
        }

        var cached = getCache(path.node);
        if (cached) {
            return cached;
        }

        var scope = new Scope(path, parentScope);
        path.node[CACHE_KEY] = scope;
        return scope;
    };

    Scope.prototype.getBinding = function getBinding(name) {
        var scope = this;

        do {
            var binding = scope.getOwnBinding(name);
            if (binding) {
                return binding;
            }
            if (scope.path.is('RootScope')) {
                return;
            }
        } while (scope = scope.parent);
    };

    Scope.prototype.getOwnBinding = function getOwnBinding(name) {
        return this.bindings[name];
    };

    Scope.prototype.hasOwnBinding = function hasOwnBinding(name) {
        return !!this.getOwnBinding(name);
    };

    Scope.prototype.hasBinding = function hasBinding(name) {
        return !name ? false : !!(this.hasOwnBinding(name) || this.parentHasBinding(name));
    };

    Scope.prototype.getRootScope = function getRootScope() {
        var scope = this;
        while (scope.parent) {
            scope = scope.parent;
        }
        return scope;
    };

    Scope.prototype.registerBinding = function registerBinding(name) {
        var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var kind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'context';

        var scope = this;
        if (kind === 'global' && path === null) {
            scope = this.getRootScope();
        } else if (kind === 'const') {
            while (scope.parent) {
                scope = scope.parent;
                if (scope.path.is('RootScope')) {
                    break;
                }
            }
        }
        // todo identify if we need to be able to differentiate between binding kinds
        // if (scope.bindings[name]) {
        // todo: warn about colliding binding or fix it
        // }
        if (this.path.state) {
            this.path.state.markIdentifier(name);
        }
        return scope.bindings[name] = new Binding(name, this, path, kind);
    };

    Scope.prototype.reference = function reference(name, path) {
        var binding = this.getBinding(name);
        if (!binding) {
            binding = this.registerBinding(name);
        }
        binding.reference(path);
    };

    Scope.prototype.parentHasBinding = function parentHasBinding(name) {
        return this.parent && this.parent.hasBinding(name);
    };

    Scope.prototype.generateUid = function generateUid() {
        var nameHint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'temp';

        var name = toIdentifier(nameHint);

        var uid = void 0,
            i = 0;
        do {
            uid = _generateUid(name, i);
            i++;
        } while (this.hasBinding(uid));

        return uid;
    };

    createClass(Scope, [{
        key: 'contextName',
        set: function set$$1(val) {
            this._contextName = val;
        },
        get: function get$$1() {
            if (this._contextName) {
                return this._contextName;
            }
            if (this.parent) {
                return this.parent.contextName || '_context';
            }
            return '_context';
        }
    }, {
        key: 'needsSubContext',
        get: function get$$1() {
            return this.escapesContext && this.hasCustomBindings;
        }
    }, {
        key: 'hasCustomBindings',
        get: function get$$1() {
            return !!Object.keys(this.bindings).length;
        }
    }]);
    return Scope;
}();


function getCache(node) {
    return node[CACHE_KEY];
}

function toIdentifier(nameHint) {
    var name = nameHint + '';
    name = name.replace(/[^a-zA-Z0-9$_]/g, '');

    name = name.replace(/^[-0-9]+/, '');
    name = name.replace(/[-\s]+(.)?/, function (match, c) {
        return c ? c.toUpperCase() : '';
    });

    name = name.replace(/^_+/, '').replace(/[0-9]+$/, '');
    return name;
}

function _generateUid(name, i) {
    if (i > 0) {
        return '_' + name + '$' + i;
    }
    return '_' + name;
}

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Path = function () {
    //region Path creation
    function Path(parent) {
        classCallCheck(this, Path);

        this.parent = parent;

        this.inList = false;
        this.listKey = null;
        this.parentKey = null;
        this.container = null;
        this.parentPath = null;

        this.key = null;
        this.node = null;
        this.type = null;

        this.state = null;

        this.data = Object.create(null);
        this.contexts = [];
        this.scope = null;
        this.visitor = null;

        this.shouldSkip = false;
        this.shouldStop = false;
        this.removed = false;
    }

    Path.get = function get$$1(_ref) {
        var parentPath = _ref.parentPath,
            parent = _ref.parent,
            container = _ref.container,
            listKey = _ref.listKey,
            key = _ref.key;

        var targetNode = container[key],
            paths = parent && parent[PATH_CACHE_KEY] || (parent ? parent[PATH_CACHE_KEY] = [] : []);
        var path = void 0;

        for (var i = 0, len = paths.length; i < len; i++) {
            var candidate = paths[i];
            if (candidate.node === targetNode) {
                path = candidate;
                break;
            }
        }

        if (!path) {
            path = new Path(parent);
        }

        path.inList = !!listKey;
        path.listKey = listKey;
        path.parentKey = listKey || key;
        path.container = container;
        path.parentPath = parentPath || path.parentPath;

        path.key = key;
        path.node = path.container[path.key];
        path.type = path.node && path.node.type;

        if (!path.node) {
            /*eslint no-console: off*/
            console.log('Path has no node ' + path.parentKey + ' > ' + path.key);
        }
        paths.push(path);

        return path;
    };

    //endregion

    //region Generic data


    Path.prototype.setData = function setData(key, val) {
        return this.data[key] = val;
    };

    Path.prototype.getData = function getData(key, def) {
        var val = this.data[key];
        if (!val && def) {
            return this.data[key] = def;
        }
        return val;
    };
    //endregion

    //region Context


    Path.prototype.pushContext = function pushContext(context) {
        this.contexts.push(context);
        this.setContext(context);
    };

    Path.prototype.popContext = function popContext() {
        this.contexts.pop();
        this.setContext(this.contexts[this.contexts.length - 1]);
    };

    Path.prototype.setContext = function setContext(context) {
        this.shouldSkip = false;
        this.shouldStop = false;
        this.removed = false;
        //this.skipKeys = {};

        if (context) {
            this.context = context;
            this.state = context.state;
            this.visitor = context.visitor;
        }

        this.setScope();
        return this;
    };

    Path.prototype.getScope = function getScope(scope) {
        if (Node.isScope(this.node)) {
            if (this.node.type === 'BlockStatement') {
                return Scope.get(this, scope.getRootScope());
            }
            return Scope.get(this, scope);
        }
        return scope;
    };

    Path.prototype.setScope = function setScope() {
        var target = this.context && this.context.scope;

        if (!target) {
            var path = this.parentPath;
            while (path && !target) {
                target = path.scope;
                path = path.parentPath;
            }
        }

        this.scope = this.getScope(target);
    };

    Path.prototype.visit = function visit$$1() {
        if (!this.node) {
            return false;
        }

        if (call(this, 'enter') || this.shouldSkip) {
            return this.shouldStop;
        }

        visit(this.node, this.visitor, this.scope, this.state, this);

        call(this, 'exit');

        return this.shouldStop;
    };

    Path.prototype.skip = function skip() {
        this.shouldSkip = true;
    };

    Path.prototype.stop = function stop() {
        this.shouldStop = true;
        this.shouldSkip = true;
    };

    Path.prototype.resync = function resync() {
        if (this.removed) {
            return;
        }

        if (this.parentPath) {
            this.parent = this.parentPath.node;
        }

        if (this.parent && this.inList) {
            var newContainer = this.parent[this.listKey];
            if (this.container !== newContainer) {
                this.container = newContainer || null;
            }
        }

        if (this.container && this.node !== this.container[this.key]) {
            this.key = null;
            if (Array.isArray(this.container)) {
                var i = void 0,
                    len = void 0;
                for (i = 0, len = this.container.length; i < len; i++) {
                    if (this.container[i] === this.node) {
                        this.setKey(i);
                        break;
                    }
                }
            } else {
                var key = void 0;
                for (key in this.container) {
                    if (this.container[key] === this.node) {
                        this.setKey(key);
                        break;
                    }
                }
            }
        }
    };

    Path.prototype.setKey = function setKey(key) {
        this.key = key;
        this.node = this.container[this.key];
        this.type = this.node && this.node.type;
    };

    Path.prototype.requeue = function requeue() {
        var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;

        if (path.removed) {
            return;
        }

        for (var _iterator = this.contexts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref2;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref2 = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref2 = _i.value;
            }

            var context = _ref2;

            context.maybeQueue(path);
        }
    };
    //endregion

    //region Modification


    Path.prototype.replaceWith = function replaceWith(value) {
        this.resync();

        var replacement = value instanceof Path ? value.node : value;

        if (this.node === replacement) {
            return;
        }

        _replaceWith(this, replacement);
        this.type = replacement.type;
        this.resync();
        this.setScope();
        this.requeue();
    };

    Path.prototype.replaceWithJS = function replaceWithJS(replacement) {
        this.resync();
        _replaceWith(this, replacement);
        this.type = replacement.type;
        this.resync();
        this.setScope();
    };

    Path.prototype.replaceWithMultipleJS = function replaceWithMultipleJS() {
        var _container;

        this.resync();

        if (!this.container) {
            throw new Error('Path does not have a container');
        }
        if (!Array.isArray(this.container)) {
            throw new Error('Container of path is not an array');
        }

        for (var _len = arguments.length, replacements = Array(_len), _key = 0; _key < _len; _key++) {
            replacements[_key] = arguments[_key];
        }

        (_container = this.container).splice.apply(_container, [this.key, 1].concat(replacements));
        this.resync();
        this.updateSiblingKeys(this.key, replacements.length - 1);
        markRemoved(this);
        //this.node = replacements[0];
    };

    Path.prototype.remove = function remove() {
        this.resync();

        if (Array.isArray(this.container)) {
            this.container.splice(this.key, 1);
            this.updateSiblingKeys(this.key, -1);
        } else {
            _replaceWith(this, null);
        }

        markRemoved(this);
    };

    Path.prototype.updateSiblingKeys = function updateSiblingKeys(fromIndex, incrementBy) {
        if (!this.parent) {
            return;
        }

        var paths = this.parent[PATH_CACHE_KEY];
        for (var _iterator2 = paths, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
            var _ref3;

            if (_isArray2) {
                if (_i2 >= _iterator2.length) break;
                _ref3 = _iterator2[_i2++];
            } else {
                _i2 = _iterator2.next();
                if (_i2.done) break;
                _ref3 = _i2.value;
            }

            var path = _ref3;

            if (path.key >= fromIndex) {
                path.key += incrementBy;
            }
        }
    };
    //endregion

    Path.prototype.is = function is$$1(type) {
        return is(this.node, type);
    };

    Path.prototype.findParentPathOfType = function findParentPathOfType(type) {
        var path = this.parentPath;
        while (path && !path.is(type)) {
            path = path.parentPath;
        }
        return path && path.type === type ? path : null;
    };

    Path.prototype.get = function get$$1(key) {
        var _this = this;

        var parts = key.split('.'),
            context = this.context;
        if (parts.length === 1) {
            var node = this.node,
                container = node[key];
            if (Array.isArray(container)) {
                return container.map(function (_, i) {
                    return Path.get({
                        listKey: key,
                        parentPath: _this,
                        parent: node,
                        container: container,
                        key: i
                    }).setContext(context);
                });
            } else {
                return Path.get({
                    parentPath: this,
                    parent: node,
                    container: node,
                    key: key
                }).setContext(context);
            }
        } else {
            var path = this;
            for (var _iterator3 = parts, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
                var _ref4;

                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref4 = _iterator3[_i3++];
                } else {
                    _i3 = _iterator3.next();
                    if (_i3.done) break;
                    _ref4 = _i3.value;
                }

                var part = _ref4;

                if (Array.isArray(path)) {
                    path = path[part];
                } else {
                    path = path.get(part);
                }
            }
            return path;
        }
    };

    return Path;
}();


function markRemoved(path) {
    path.shouldSkip = true;
    path.removed = true;
    path.node = null;
}

function _replaceWith(path, node) {
    if (!path.container) {
        throw new Error('Path does not have a container');
    }

    path.node = path.container[path.key] = node;
}

function call(path, key) {
    if (!path.node) {
        return false;
    }

    var visitor = path.visitor[path.node.type];
    if (!visitor || !visitor[key]) {
        return false;
    }

    var fns = visitor[key];
    for (var i = 0, len = fns.length; i < len; i++) {
        var fn = fns[i];
        if (!fn) {
            continue;
        }

        var node = path.node;
        if (!node) {
            return true;
        }

        fn.call(path.state, path, path.state);

        // node has been replaced, requeue
        if (path.node !== node) {
            return true;
        }

        if (path.shouldStop || path.shouldSkip || path.removed) {
            return true;
        }
    }

    return false;
}

/**
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { Scope, Path, merge, explode, traverse, visit };
