"use strict";
exports.__esModule = true;
var cache_1 = require("./cache");
var util_1 = require("./util");
// tslint:disable-next-line:no-var-requires
var pkg = require("../package.json");
/*
 * Simply passing text to elm-format is not enough because of two problems:
 *
 * 1. If the code chunk only contains an import statement, no formatting takes place.
 *    Related to: https://github.com/avh4/elm-format/issues/551
 * 2. `module Main exposing (.*)` is always added if no module has been defined,
 *    which is not wanted in markdown code blocks.
 *    Related to: https://github.com/avh4/elm-format/issues/65
 *
 * Until the upstream issues are fixed, two custom patches are applied:
 *
 * 1. A dummy comment is added to the source and is then removed from the result.
 * 2. If current context is a markdown block and the source does not declare a module,
 *    module statement is removed from the result.
 *
 * Please submit an issue to https://github.com/gicentre/prettier-plugin-elm/issues
 * if there are any problems caused by the patches.
 */
var dummyComment = "\n{- DUMMY COMMENT BY PRETTIER-PLUGIN-ELM -}";
var dummyCommentRemovalRegExp = /\n*\{- DUMMY COMMENT BY PRETTIER-PLUGIN-ELM -\}/;
var autogeneratedModuleDefinitionRegExp = /[ \t]*module\s+Main\s+exposing\s+\([^\n]+\)\n*/;
exports.parse = function (text, parsers, opts) {
    // patch 1 step 1
    var textToSend = "" + text + dummyComment;
    // extract formatted text from elm-format
    var formattedText = cache_1.getCachedValue(util_1.formatTextWithElmFormat, [textToSend], [pkg.version, util_1.getElmFormatVersion()]);
    // patch 1 step 2
    formattedText = formattedText.replace(dummyCommentRemovalRegExp, "");
    if (formattedText === "\n") {
        formattedText = "";
    }
    // patch 2
    if (opts.parentParser === "markdown" &&
        autogeneratedModuleDefinitionRegExp.test(formattedText) &&
        !autogeneratedModuleDefinitionRegExp.test(text)) {
        formattedText = formattedText.replace(autogeneratedModuleDefinitionRegExp, "");
        formattedText = formattedText.replace(/\n+$/, "\n");
    }
    // return an AST with a single node that contain all the formatted elm code;
    // no further splitting into smaller tokens is made
    return {
        ast_type: "elm-format",
        body: formattedText,
        end: text.length,
        source: text,
        start: 0
    };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3BhcnNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLGlDQUF5QztBQUN6QywrQkFBc0U7QUFFdEUsMkNBQTJDO0FBQzNDLElBQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBRXZDOzs7Ozs7Ozs7Ozs7Ozs7OztHQWlCRztBQUVILElBQU0sWUFBWSxHQUFHLDhDQUE4QyxDQUFDO0FBQ3BFLElBQU0seUJBQXlCLEdBQUcsaURBQWlELENBQUM7QUFDcEYsSUFBTSxtQ0FBbUMsR0FBRyxnREFBZ0QsQ0FBQztBQUVoRixRQUFBLEtBQUssR0FBRyxVQUNuQixJQUFZLEVBQ1osT0FBeUMsRUFDekMsSUFBK0M7SUFFL0MsaUJBQWlCO0lBQ2pCLElBQU0sVUFBVSxHQUFHLEtBQUcsSUFBSSxHQUFHLFlBQWMsQ0FBQztJQUU1Qyx5Q0FBeUM7SUFDekMsSUFBSSxhQUFhLEdBQUcsc0JBQWMsQ0FDaEMsOEJBQXVCLEVBQ3ZCLENBQUMsVUFBVSxDQUFDLEVBQ1osQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLDBCQUFtQixFQUFFLENBQUMsQ0FDckMsQ0FBQztJQUVGLGlCQUFpQjtJQUNqQixhQUFhLEdBQUcsYUFBYSxDQUFDLE9BQU8sQ0FBQyx5QkFBeUIsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNyRSxJQUFJLGFBQWEsS0FBSyxJQUFJLEVBQUU7UUFDMUIsYUFBYSxHQUFHLEVBQUUsQ0FBQztLQUNwQjtJQUVELFVBQVU7SUFDVixJQUNFLElBQUksQ0FBQyxZQUFZLEtBQUssVUFBVTtRQUNoQyxtQ0FBbUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBQ3ZELENBQUMsbUNBQW1DLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUMvQztRQUNBLGFBQWEsR0FBRyxhQUFhLENBQUMsT0FBTyxDQUNuQyxtQ0FBbUMsRUFDbkMsRUFBRSxDQUNILENBQUM7UUFDRixhQUFhLEdBQUcsYUFBYSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDckQ7SUFFRCw0RUFBNEU7SUFDNUUsbURBQW1EO0lBQ25ELE9BQU87UUFDTCxRQUFRLEVBQUUsWUFBWTtRQUN0QixJQUFJLEVBQUUsYUFBYTtRQUNuQixHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU07UUFDaEIsTUFBTSxFQUFFLElBQUk7UUFDWixLQUFLLEVBQUUsQ0FBQztLQUNULENBQUM7QUFDSixDQUFDLENBQUMifQ==