import { enqueueComponent } from './renderQueue';
declare type Class<T> = {
    new (): T;
};
export interface CallableComponent {
    apply(props: any): void;
    el: Element;
}
export interface RenderableComponent {
    el: Element;
    refs: any;
    render(): void;
    notify(): void;
    type: String;
}
declare const patchInner: (node: any, fn: any, data: any) => any;
declare const patchOuter: (node: any, fn: any, data: any) => any;
declare var updateComponent: (comp: RenderableComponent) => void;
declare var component: (Component: CallableComponent | Class<CallableComponent>, key: string, props: any) => any;
declare var getCurrentComponent: () => RenderableComponent;
declare var mount: (element: Node, Component: CallableComponent | Class<CallableComponent>, props: any) => any;
/**
 * Makes sure that the current node is an Element with a matching tagName and
 * key.
 *
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @return {!Element} The corresponding Element.
 */
declare var elementOpen: (tag: string, key?: string) => any;
/**
 * Closes the currently open Element, removing any unvisited children if
 * necessary.
 *
 * @return {!Element} The corresponding Element.
 */
declare var elementClose: () => void;
/**
 * Makes sure the current node is a Text node and creates a Text node if it is
 * not.
 *
 * @return {!Text} The corresponding Text Node.
 */
declare var text: () => Text;
/**
 * Gets the current Element being patched.
 * @return {!Element}
 */
declare var currentElement: () => Node;
/**
 * Skips the children in a subtree, allowing an Element to be closed without
 * clearing out the children.
 */
declare var skip: () => void;
declare var inPatch: () => boolean;
declare const skipNode: () => void;
declare var raw: (html: string) => void;
/** */
export { elementOpen, elementClose, text, patchInner, patchOuter, currentElement, skip, skipNode, inPatch, raw, mount, component, getCurrentComponent as currentComponent, updateComponent, enqueueComponent, };
