/**
 * Copyright 2015 The Incremental DOM Authors.
 * Copyright 2017 trivago N.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { patchOuter, updateComponent } from './core';
import { getParent } from './hierarchy';
import { debounce } from 'lodash';
import options from './options';
var supportsPassiveListeners = false;
/* istanbul ignore next */
document.createElement('div').addEventListener('test', function () { }, {
    get passive() {
        supportsPassiveListeners = true;
        return false;
    },
});
var BUSY_FRAME_LENGTH = 3;
var IDLE_FRAME_LENGTH = 30;
var MESSAGE_KEY = '__melodyPrioritize_' +
    Math.random()
        .toString(36)
        .slice(2);
export var mountedComponents = new WeakSet();
// by default we assume that we have to deal with a busy frame
// we can afford a little more time if we can detect that the
// browser is currently idle (=not scrolling)
var idealFrameLength = IDLE_FRAME_LENGTH;
var scrollListenerAttached = false;
var prioritizationRequested = false;
var prioritizationDisabled = !!options.experimentalSyncDeepRendering;
var NIL = { component: null, next: null };
var queue = NIL;
function isEmpty() {
    return queue === NIL;
}
function addToQueue(component) {
    if (queue !== NIL) {
        // before we schedule this update, we should check a few things first
        for (var head = queue; head !== NIL; head = head.next) {
            // 1: Has this component already been scheduled for an update?
            if (head.component === component) {
                // if so: we don't need
                return;
            }
            if (component.type !== 'streaming') {
                // 2: Is the parent of this component already scheduled for an update?
                if (getParent(component) === head.component) {
                    // if so: we don't need to do anything
                    return;
                }
                // 3: Is the component a parent of a node within the queue?
                if (getParent(head.component) === component) {
                    // if so: replace the child with its parent
                    head.component = component;
                    return;
                }
            }
            if (head.next === NIL) {
                // insert the new node at the end of the list
                // we probably want to adjust that once we know how
                // to prioritize an update
                head.next = {
                    component: component,
                    next: NIL,
                };
                break;
            }
        }
    }
    else {
        queue = {
            component: component,
            next: NIL,
        };
    }
}
export function drop(component) {
    if (queue === NIL) {
        return;
    }
    if (queue.component === component) {
        queue = queue.next;
    }
    var prev = queue;
    for (var head = queue.next; head && head !== NIL; head = head.next) {
        // is the component (or one of its parents) in the queue the removed component?
        var comp = head.component;
        do {
            if (comp === component) {
                // if so: drop it
                prev.next = head.next;
                head = prev;
                break;
            }
            comp = getParent(comp);
        } while (comp);
        prev = head;
    }
}
function getPriority(node) {
    if (!node.component.el) {
        return -1;
    }
    var windowHeight = window.innerHeight || document.documentElement.clientHeight;
    var _a = node.component.el.getBoundingClientRect(), top = _a.top, bottom = _a.bottom;
    // is fully visible
    if ((0 < top && bottom < windowHeight) ||
        (top < 0 && windowHeight < bottom)) {
        return 0;
    }
    // bottom of component is visible
    if (top < 0 && 0 < bottom && bottom < windowHeight) {
        return 1;
    }
    // top of component is visible
    if (0 < top && top < windowHeight) {
        return 2;
    }
    // not visible, not new
    return 3;
}
function prioritizeQueue(queue) {
    var buckets = new Array(4);
    for (var head = queue; head !== NIL; head = head.next) {
        var bucketIndex = getPriority(head);
        if (bucketIndex < 0) {
            continue;
        }
        var clone = { component: head.component, next: NIL };
        if (!buckets[bucketIndex]) {
            buckets[bucketIndex] = { first: clone, last: clone };
        }
        else {
            buckets[bucketIndex].last.next = clone;
            buckets[bucketIndex].last = clone;
        }
    }
    return buckets.reduceRight(concatWithKnownLast, NIL);
}
function concatWithKnownLast(queue, _a) {
    var first = _a.first, last = _a.last;
    var newList = concat(last, queue);
    return newList === last ? first : newList;
}
function concat(queue, nextQueue) {
    if (queue === NIL) {
        return nextQueue;
    }
    var p = queue;
    while (p.next !== NIL) {
        if (nextQueue === NIL) {
            return queue;
        }
        if (nextQueue.component === p.component) {
            nextQueue = nextQueue.next;
        }
        else {
            var prev = nextQueue;
            for (var head = nextQueue.next; head && head !== NIL; head = head.next) {
                if (head.component === p.component) {
                    prev.next = head.next;
                    break;
                }
                prev = head;
            }
        }
        p = p.next;
    }
    p.next = nextQueue;
    return queue;
}
function pop() {
    if (isEmpty()) {
        return null;
    }
    var head = queue;
    queue = queue.next;
    return head;
}
var isTicking = false;
function tick(callback) {
    if (isTicking) {
        return;
    }
    isTicking = true;
    requestAnimationFrame(function () {
        var startTime = Date.now();
        callback({
            didTimeout: false,
            timeRemaining: function () {
                return Math.max(0, idealFrameLength - (Date.now() - startTime));
            },
        });
    });
}
function drain() {
    var next = pop();
    var mounted = [];
    while (next) {
        if (next.component.el) {
            patchOuter(next.component.el, function (_) { return updateComponent(next.component); }, {});
            mounted.push(next.component);
        }
        next = pop();
    }
    return mounted;
}
export function flush(deadline) {
    var prevQueue;
    var next = pop();
    var hasNew = false;
    var mounted = new Set();
    while (next) {
        prevQueue = queue;
        queue = NIL;
        if (next.component.el) {
            var isNew = next.component.el.localName === 'm-placeholder';
            patchOuter(next.component.el, function (_) { return updateComponent(next.component); }, {});
            mounted.add(next.component);
            if (isNew && queue !== NIL) {
                var drained = drain();
                for (var i = 0; i < drained.length; i++) {
                    mounted.add(drained[i]);
                }
                queue = NIL;
            }
        }
        if (queue !== NIL) {
            hasNew = true;
        }
        queue = concat(queue, prevQueue);
        if (options.experimentalSyncDeepRendering) {
            next = pop();
        }
        else {
            next = 0 < deadline.timeRemaining() ? pop() : null;
        }
    }
    // notify the freshly mounted components
    var notified = mounted.values();
    for (var current = notified.next(); !current.done; current = notified.next()) {
        var comp = current.value;
        if (comp.el) {
            mountedComponents.add(comp);
            comp.notify();
        }
    }
    isTicking = false;
    if (!isEmpty()) {
        if (!prioritizationDisabled && !prioritizationRequested && hasNew) {
            prioritizationRequested = true;
            window.postMessage(MESSAGE_KEY, '*');
        }
        tick(flush);
    }
}
export function clear() {
    if (process.env.NODE_ENV !== 'test') {
        throw new Error('Clearing the queue is only allowed within a test environment.');
    }
    queue = NIL;
}
function performReordering(event) {
    if (event.source !== this || event.data !== MESSAGE_KEY) {
        return;
    }
    prioritizationRequested = false;
    var timeSpent = Date.now();
    queue = prioritizeQueue(queue);
    timeSpent = Date.now() - timeSpent;
    // Usually prioritization takes 0 - 4 ms on fast browsers. If browser is not
    // able to do that (like Edge/IE) in this period skip the process.
    if (timeSpent > 10) {
        prioritizationDisabled = true;
    }
}
window.addEventListener('message', performReordering, false);
export function enqueueComponent(component) {
    /* istanbul ignore if */
    if (supportsPassiveListeners && !scrollListenerAttached) {
        attachScrollListener();
    }
    addToQueue(component);
    /* istanbul ignore else */
    if (process.env.NODE_ENV === 'test') {
        return;
    }
    tick(flush);
}
/* istanbul ignore next */
var detectIdleCallback = debounce(function detectIdleCallback() {
    idealFrameLength = IDLE_FRAME_LENGTH;
}, 300);
/* istanbul ignore next */
function attachScrollListener() {
    scrollListenerAttached = true;
    // if we can detect when the browser is busy
    // then we can assume its idle by default
    idealFrameLength = IDLE_FRAME_LENGTH;
    document.addEventListener('scroll', function () {
        idealFrameLength = BUSY_FRAME_LENGTH;
        detectIdleCallback();
    }, { passive: true });
}
